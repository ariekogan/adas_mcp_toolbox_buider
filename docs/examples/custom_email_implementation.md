# Custom Tool Implementation Guide: Email Tools

This guide demonstrates how to add custom email tools (send_email, read_emails) to your ADAS skill, from definition through implementation.

## Overview

There are **two layers** to consider when adding custom tools:

1. **Tool Definition** (YAML/JSON) - Defines the tool interface that ADAS uses
2. **Tool Implementation** (Python/JS) - The actual code that executes when the tool is called

## Step 1: Define the Tool Interface

Add these tools to your skill's `tools` section. You can do this via:
- The DAL Builder UI (conversational)
- Directly editing the domain.json
- Using a template

### Example: send_email Tool Definition

```yaml
- id: "tool-email-send"
  id_status: permanent
  name: "send_email"
  description: |
    Send an email to one or more recipients. Supports plain text and HTML
    content, attachments, CC/BCC, and reply-to headers.
  inputs:
    - name: "to"
      type: array
      required: true
      description: "Array of recipient email addresses"
    - name: "subject"
      type: string
      required: true
      description: "Email subject line"
    - name: "body"
      type: string
      required: true
      description: "Email body content"
    - name: "body_type"
      type: string
      required: false
      description: "Content type: text or html"
      enum: ["text", "html"]
      default: "text"
    - name: "cc"
      type: array
      required: false
      description: "CC recipients"
    - name: "bcc"
      type: array
      required: false
      description: "BCC recipients"
  output:
    type: object
    description: "Send result"
    schema:
      success: "boolean"
      message_id: "string"
      timestamp: "string"
  policy:
    allowed: always
    requires_approval: always  # IMPORTANT: Always require approval for sending
  mock:
    enabled: true
    mode: examples
    examples:
      - id: "send-simple"
        input:
          to: ["user@example.com"]
          subject: "Test"
          body: "Hello world"
        output:
          success: true
          message_id: "msg-123"
          timestamp: "2026-01-19T10:00:00Z"
```

### Example: read_emails Tool Definition

```yaml
- id: "tool-email-read"
  id_status: permanent
  name: "read_emails"
  description: |
    Read emails from inbox with filtering options.
  inputs:
    - name: "folder"
      type: string
      required: false
      default: "inbox"
      enum: ["inbox", "sent", "drafts", "trash"]
    - name: "limit"
      type: number
      required: false
      default: 20
    - name: "unread_only"
      type: boolean
      required: false
      default: false
    - name: "from_filter"
      type: string
      required: false
      description: "Filter by sender"
    - name: "subject_filter"
      type: string
      required: false
      description: "Filter by subject"
  output:
    type: object
    schema:
      emails: "array"
      total_count: "number"
      has_more: "boolean"
  policy:
    allowed: always
    requires_approval: never  # Reading is safe
  mock:
    enabled: true
    mode: examples
    examples:
      - id: "read-inbox"
        input:
          folder: "inbox"
          limit: 10
        output:
          emails:
            - id: "email-001"
              from: "sender@example.com"
              subject: "Meeting"
              date: "2026-01-19T09:00:00Z"
              is_read: false
          total_count: 45
          has_more: true
```

## Step 2: Export the MCP Server

When you export your skill, the toolbox builder generates a Python MCP server with mock implementations based on your examples.

The generated code looks like:

```python
"""
MCP Server: Email Assistant
Generated by ADAS MCP Toolbox Builder
"""

from mcp.server.fastmcp import FastMCP

mcp = FastMCP("Email Assistant")

@mcp.tool()
def send_email(to: list, subject: str, body: str, body_type: str = None, cc: list = None, bcc: list = None) -> dict:
    """
    Send an email to one or more recipients.

    Args:
        to: Array of recipient email addresses
        subject: Email subject line
        body: Email body content
        body_type: Content type: text or html
        cc: CC recipients
        bcc: BCC recipients

    Returns:
        Send result with success status and message_id
    """
    # Mock implementation - TODO: Replace with actual logic
    mock_data = {
        '{"to": ["user@example.com"], "subject": "Test", "body": "Hello world"}':
            {"success": True, "message_id": "msg-123", "timestamp": "2026-01-19T10:00:00Z"},
    }

    input_key = str({"to": to, "subject": subject, "body": body})
    if input_key in mock_data:
        return mock_data[input_key]

    return {"success": False, "error": "No matching mock data"}

@mcp.tool()
def read_emails(folder: str = None, limit: int = None, unread_only: bool = None, from_filter: str = None) -> dict:
    """
    Read emails from inbox with filtering options.
    """
    # Mock implementation - TODO: Replace with actual logic
    return {
        "emails": [
            {"id": "email-001", "from": "sender@example.com", "subject": "Meeting"}
        ],
        "total_count": 45,
        "has_more": True
    }

if __name__ == "__main__":
    mcp.run()
```

## Step 3: Implement Real Logic

Replace the mock implementations with actual email provider code. Here are examples for different providers:

### Option A: Gmail (Google API)

```python
import os
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from email.mime.text import MIMEText
import base64

# Initialize Gmail API
creds = Credentials.from_authorized_user_file('token.json')
service = build('gmail', 'v1', credentials=creds)

@mcp.tool()
def send_email(to: list, subject: str, body: str, body_type: str = "text", cc: list = None, bcc: list = None) -> dict:
    """Send email via Gmail API"""
    try:
        message = MIMEText(body, body_type)
        message['to'] = ', '.join(to)
        message['subject'] = subject
        if cc:
            message['cc'] = ', '.join(cc)

        raw = base64.urlsafe_b64encode(message.as_bytes()).decode()
        result = service.users().messages().send(
            userId='me',
            body={'raw': raw}
        ).execute()

        return {
            "success": True,
            "message_id": result['id'],
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        return {"success": False, "error": str(e)}

@mcp.tool()
def read_emails(folder: str = "inbox", limit: int = 20, unread_only: bool = False, from_filter: str = None) -> dict:
    """Read emails via Gmail API"""
    try:
        query_parts = []
        if folder == "inbox":
            query_parts.append("in:inbox")
        if unread_only:
            query_parts.append("is:unread")
        if from_filter:
            query_parts.append(f"from:{from_filter}")

        query = ' '.join(query_parts) if query_parts else None

        results = service.users().messages().list(
            userId='me',
            q=query,
            maxResults=limit
        ).execute()

        emails = []
        for msg in results.get('messages', []):
            detail = service.users().messages().get(
                userId='me',
                id=msg['id'],
                format='metadata'
            ).execute()

            headers = {h['name']: h['value'] for h in detail['payload']['headers']}
            emails.append({
                "id": msg['id'],
                "from": headers.get('From', ''),
                "subject": headers.get('Subject', ''),
                "date": headers.get('Date', ''),
                "is_read": 'UNREAD' not in detail.get('labelIds', [])
            })

        return {
            "emails": emails,
            "total_count": results.get('resultSizeEstimate', len(emails)),
            "has_more": 'nextPageToken' in results
        }
    except Exception as e:
        return {"emails": [], "total_count": 0, "has_more": False, "error": str(e)}
```

### Option B: SMTP (Generic)

```python
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import imaplib
import email

SMTP_HOST = os.environ.get('SMTP_HOST', 'smtp.gmail.com')
SMTP_PORT = int(os.environ.get('SMTP_PORT', '587'))
EMAIL_USER = os.environ.get('EMAIL_USER')
EMAIL_PASS = os.environ.get('EMAIL_PASS')

@mcp.tool()
def send_email(to: list, subject: str, body: str, body_type: str = "text", cc: list = None, bcc: list = None) -> dict:
    """Send email via SMTP"""
    try:
        msg = MIMEMultipart()
        msg['From'] = EMAIL_USER
        msg['To'] = ', '.join(to)
        msg['Subject'] = subject
        if cc:
            msg['Cc'] = ', '.join(cc)

        subtype = 'html' if body_type == 'html' else 'plain'
        msg.attach(MIMEText(body, subtype))

        all_recipients = to + (cc or []) + (bcc or [])

        with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as server:
            server.starttls()
            server.login(EMAIL_USER, EMAIL_PASS)
            server.sendmail(EMAIL_USER, all_recipients, msg.as_string())

        return {
            "success": True,
            "message_id": f"smtp-{datetime.now().timestamp()}",
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        return {"success": False, "error": str(e)}

@mcp.tool()
def read_emails(folder: str = "inbox", limit: int = 20, unread_only: bool = False, from_filter: str = None) -> dict:
    """Read emails via IMAP"""
    try:
        imap = imaplib.IMAP4_SSL('imap.gmail.com')
        imap.login(EMAIL_USER, EMAIL_PASS)
        imap.select(folder.upper())

        search_criteria = 'UNSEEN' if unread_only else 'ALL'
        if from_filter:
            search_criteria = f'(FROM "{from_filter}")'

        _, message_numbers = imap.search(None, search_criteria)

        emails = []
        for num in message_numbers[0].split()[-limit:]:
            _, msg_data = imap.fetch(num, '(RFC822)')
            email_body = msg_data[0][1]
            msg = email.message_from_bytes(email_body)

            emails.append({
                "id": num.decode(),
                "from": msg['From'],
                "subject": msg['Subject'],
                "date": msg['Date'],
                "is_read": True  # Simplified
            })

        imap.close()
        imap.logout()

        return {
            "emails": emails,
            "total_count": len(message_numbers[0].split()),
            "has_more": len(message_numbers[0].split()) > limit
        }
    except Exception as e:
        return {"emails": [], "total_count": 0, "error": str(e)}
```

### Option C: Microsoft Graph (Outlook/Office 365)

```python
import msal
import requests

CLIENT_ID = os.environ.get('MS_CLIENT_ID')
CLIENT_SECRET = os.environ.get('MS_CLIENT_SECRET')
TENANT_ID = os.environ.get('MS_TENANT_ID')

def get_access_token():
    app = msal.ConfidentialClientApplication(
        CLIENT_ID,
        authority=f"https://login.microsoftonline.com/{TENANT_ID}",
        client_credential=CLIENT_SECRET
    )
    result = app.acquire_token_for_client(scopes=["https://graph.microsoft.com/.default"])
    return result['access_token']

@mcp.tool()
def send_email(to: list, subject: str, body: str, body_type: str = "text", cc: list = None, bcc: list = None) -> dict:
    """Send email via Microsoft Graph"""
    try:
        token = get_access_token()
        headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}

        message = {
            "message": {
                "subject": subject,
                "body": {
                    "contentType": "HTML" if body_type == "html" else "Text",
                    "content": body
                },
                "toRecipients": [{"emailAddress": {"address": addr}} for addr in to],
            }
        }

        if cc:
            message["message"]["ccRecipients"] = [{"emailAddress": {"address": addr}} for addr in cc]

        response = requests.post(
            "https://graph.microsoft.com/v1.0/me/sendMail",
            headers=headers,
            json=message
        )

        return {
            "success": response.status_code == 202,
            "message_id": f"graph-{datetime.now().timestamp()}",
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        return {"success": False, "error": str(e)}
```

## Step 4: Add Intents and Workflows

To make your email tools accessible via natural language, add these intents:

```yaml
intents:
  supported:
    - id: "intent_send_email"
      description: "User wants to send an email"
      examples:
        - "Send an email to john@example.com"
        - "Email the team about the meeting"
        - "Compose a message to the client"
        - "Write an email to support"
      maps_to_workflow: "workflow_compose_email"
      entities:
        - name: "recipient"
          type: string
          required: false
          extract_from: message
        - name: "topic"
          type: string
          required: false
          extract_from: message

    - id: "intent_check_email"
      description: "User wants to check emails"
      examples:
        - "Check my inbox"
        - "Do I have new emails?"
        - "Read my unread messages"
        - "What emails did I get today?"
      maps_to_workflow: "workflow_check_inbox"

    - id: "intent_search_email"
      description: "User wants to find specific emails"
      examples:
        - "Find the email from John about the project"
        - "Search for invoices"
        - "Look for the meeting invite from yesterday"
```

## Step 5: Security Considerations

### Policy Configuration

```yaml
policy:
  guardrails:
    never:
      - "Send emails without user approval"
      - "Delete emails permanently"
      - "Forward emails to unknown addresses automatically"
      - "Access email accounts without proper authentication"

    always:
      - "Request approval before sending any email"
      - "Show email preview before sending"
      - "Log all email operations"
      - "Verify recipient addresses before sending"

  approvals:
    - id: "approval-send-email"
      tool_id: "tool-email-send"
      conditions:
        - when: "always"
          action: require_approval
          message: "Please confirm you want to send this email"
      approver: "user"

    - id: "approval-forward-email"
      tool_id: "tool-email-forward"
      conditions:
        - when: "always"
          action: require_approval
          message: "Please confirm you want to forward this email"
      approver: "user"
```

### Environment Variables

Never hardcode credentials. Use environment variables:

```bash
# .env file (never commit this!)
EMAIL_USER=your-email@example.com
EMAIL_PASS=your-app-password
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587

# For Gmail API
GOOGLE_APPLICATION_CREDENTIALS=/path/to/credentials.json

# For Microsoft Graph
MS_CLIENT_ID=your-client-id
MS_CLIENT_SECRET=your-client-secret
MS_TENANT_ID=your-tenant-id
```

## Summary

To add custom email tools:

1. **Define the tool interface** in your skill YAML/JSON
2. **Add mock examples** for testing in the DAL Builder
3. **Export the MCP server** to get the base code
4. **Replace mock implementations** with actual provider code
5. **Add intents and workflows** for natural language access
6. **Configure security policies** to require approval for sending
7. **Use environment variables** for credentials

The full email tools template is available at:
`/docs/templates/email_tools_example.yaml`
