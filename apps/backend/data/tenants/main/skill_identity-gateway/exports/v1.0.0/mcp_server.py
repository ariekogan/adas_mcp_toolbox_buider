"""
MCP Server: Users need to be identified and verified before accessing the scheduling system, whether they are internal team members or external customers.
Generated by ADAS MCP Toolbox Builder
Version: 1.0.0
"""

from mcp.server.fastmcp import FastMCP

mcp = FastMCP("Users need to be identified and verified before accessing the scheduling system, whether they are internal team members or external customers.")

# ── Skill Definition YAML (embedded for ADAS Core get_skill_definition) ──
SKILL_DEFINITION_YAML = """
# Skill Configuration
# Generated by ADAS MCP Toolbox Builder
# Version: 1.0.0

id: skill_identity-gateway
name: Identity Gateway
version: 1.0.0
phase: TOOL_DEFINITION

# Connectors - MCP servers managed by ADAS MCPGateway
connectors:
  - identity-mcp

# Problem Definition
problem:
  statement: Users need to be identified and verified before accessing the scheduling system, whether they are internal team members or external customers.
  context: A scheduling platform serving both internal employees and external customers booking appointments via Google Calendar.
  goals:
    - Verify user identity via email lookup
    - Distinguish between team members and customers
    - Grant verified identity claims to downstream scheduling skill

# Agent Role
role:
  name: Identity Verification Specialist
  persona: You are a friendly and efficient identity verification agent for a scheduling platform. You greet users, ask for their email to verify their identity, and route them to the scheduling assistant once verified. You are clear and helpful when a user cannot be found.

# Persona (top-level for Core ADAS)
persona: You are a friendly and efficient identity verification agent for a scheduling platform. You greet users, ask for their email to verify their identity, and route them to the scheduling assistant once verified. You are clear and helpful when a user cannot be found.

# Usage Scenarios
scenarios:
  - id: team-member-login
    title: Team member identifies themselves
    description: An internal team member provides their email to be verified before booking meetings.
    steps:
      - "User says 'Hi, I'm alice@company.com and I need to book a meeting'"
      - Agent looks up the email in the identity system
      - Agent verifies the user is a team_member
      - Agent hands off to the Scheduling Agent with verified grants
    expected_outcome: User is verified as a team member and routed to scheduling.
  - id: customer-login
    title: Customer identifies themselves
    description: An external customer provides their email to book an appointment.
    steps:
      - "User says 'I'd like to book a consultation, my email is bob@gmail.com'"
      - Agent looks up the email in the identity system
      - Agent verifies the user is a customer
      - Agent hands off to the Scheduling Agent with verified grants
    expected_outcome: User is verified as a customer and routed to scheduling.
  - id: unknown-user
    title: Unknown user tries to access
    description: A user provides an email that is not in the system.
    steps:
      - "User says 'I want to book a meeting, my email is unknown@random.com'"
      - Agent looks up the email — no match found
      - Agent asks the user to register or provides instructions
    expected_outcome: User is informed they need to register before using the scheduling system.

# Supported Intents
intents:
  supported:
    - id: identify_self
      description: User wants to identify themselves to access scheduling
      examples:
        - "Hi, I'm alice@company.com"
        - I need to book a meeting, my email is bob@gmail.com
        - Let me sign in — alice@company.com
        - "I want to schedule something, I'm john@example.com"
      entities:
        - name: email
          type: string
          required: true
    - id: ask_about_scheduling
      description: User asks about scheduling without identifying themselves first
      examples:
        - I want to book a meeting
        - Can I schedule an appointment?
        - What times are available?
        - I need to reschedule

# Available Tools
tools:
  - id: tool-identity-lookup
    name: identity.user.lookup
    description: Look up a user by email address. Returns verified user ID, type (team_member or customer), and profile.
    inputs:
      - name: email
        type: string
        required: true
        description: Email address to look up
    output:
      type: object
      description: User profile with user_id, user_type (team_member or customer), name, email, and status
    policy:
      allowed: always
    security:
      classification: pii_read

# Policy & Guardrails
policy:
  guardrails:
    never:
      - Skip identity verification and route users directly to scheduling
      - "Share one user's information with another user"
      - Create or modify user accounts
      - Reveal internal system IDs or database details
    always:
      - "Ask for the user's email before doing anything else"
      - Verify user identity before handing off to scheduling
      - Inform unregistered users how to get access
  workflows:
    - name: Identity Verification
      trigger: identify_self
      steps:
        - identity.user.lookup
        - sys.emitUserMessage
      required: true

# Identity & Access Control
grant_mappings:
  - tool: identity.user.lookup
    on_success: true
    grants:
      - key: sched.user_id
        value_from: $.user_id
        ttl_seconds: 3600
      - key: sched.user_type
        value_from: $.user_type
        ttl_seconds: 3600

access_policy:
  rules:
    - tools: [*]
      effect: allow

# Engine Configuration
engine:
  model: claude-sonnet-4-20250514
  temperature: 0.3
  max_tokens: 4096
  max_iterations: 6
  timeout: 60000
  on_max_iterations: fail
  finalization_gate:
    enabled: true
    max_retries: 2
  internal_error:
    enabled: true
    tool_not_found:
      enter_resolution_after: 1
      retryable: false
    resolution:
      max_iterations: 1
      allowed_capabilities: ["read", "search", "document_output"]
    loop_detection:
      enabled: true
      identical_call_threshold: 2
"""

@mcp.tool(name="identity.user.lookup")
def identity_user_lookup(email: str) -> dict:
    """
    Tool description

    Args:
        email: Email address to look up

    Returns:
        User profile with user_id, user_type (team_member or customer), name, email, and status
    """
    # Mock implementation for testing
    # TODO: Replace with actual logic
    mock_data = {
        {"email":"alice@company.com"}: {"user_id":"USR-001","user_type":"team_member","name":"Alice Johnson","email":"alice@company.com","status":"active"},
        {"email":"bob@gmail.com"}: {"user_id":"USR-200","user_type":"customer","name":"Bob Smith","email":"bob@gmail.com","status":"active"},
        {"email":"unknown@random.com"}: {"error":"USER_NOT_FOUND","message":"No user found with that email address"},
    }
    
    # Try to find matching mock data
    input_key = str({"email": email})
    if input_key in mock_data:
        return mock_data[input_key]
    
    # Default response if no mock match
    return {"user_id":"USR-001","user_type":"team_member","name":"Alice Johnson","email":"alice@company.com","status":"active","_note":"No matching mock data"}

@mcp.tool()
def get_skill_definition() -> dict:
    """Get the complete skill definition YAML for ADAS Core installation.

    Returns the full skill configuration including problem statement,
    tool definitions, policy, guardrails, engine config, ui_plugins,
    and external connector references.
    """
    return {
        "format": "yaml",
        "content": SKILL_DEFINITION_YAML.strip(),
        "skill_name": "Identity Gateway",
        "version": "1.0.0"
    }

@mcp.tool()
def health_check() -> dict:
    """Check server health."""
    return {"status": "healthy", "server": "Identity Gateway"}

if __name__ == "__main__":
    import os
    transport = os.environ.get("MCP_TRANSPORT", "sse")
    port = int(os.environ.get("MCP_PORT", "8100"))
    host = os.environ.get("MCP_HOST", "0.0.0.0")

    if transport == "sse":
        import uvicorn
        uvicorn.run(mcp.sse_app(), host=host, port=port)
    else:
        mcp.run()
