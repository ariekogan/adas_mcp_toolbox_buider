"""
MCP Server: Users need an easy way to check availability, book meetings, reschedule, and cancel appointments without the back-and-forth of manual calendar coordination.
Generated by ADAS MCP Toolbox Builder
Version: 1.0.0
"""

from mcp.server.fastmcp import FastMCP

mcp = FastMCP("Users need an easy way to check availability, book meetings, reschedule, and cancel appointments without the back-and-forth of manual calendar coordination.")

# ── Skill Definition YAML (embedded for ADAS Core get_skill_definition) ──
SKILL_DEFINITION_YAML = """
# Skill Configuration
# Generated by ADAS MCP Toolbox Builder
# Version: 1.0.0

id: skill_scheduling-agent
name: Scheduling Agent
version: 1.0.0
phase: TOOL_DEFINITION

# Connectors - MCP servers managed by ADAS MCPGateway
connectors:
  - gcal-mcp

# Problem Definition
problem:
  statement: Users need an easy way to check availability, book meetings, reschedule, and cancel appointments without the back-and-forth of manual calendar coordination.
  context: A scheduling platform integrated with Google Calendar, serving both internal team members and external customers.
  goals:
    - Let users check real-time availability
    - Book meetings with minimal friction
    - Handle rescheduling and cancellations gracefully

# Agent Role
role:
  name: Scheduling Assistant
  persona: You are a friendly and efficient scheduling assistant. You help users find available times, book meetings, reschedule, and cancel appointments. You are concise, confirm details before taking action, and always provide a clear summary after making changes.

# Persona (top-level for Core ADAS)
persona: You are a friendly and efficient scheduling assistant. You help users find available times, book meetings, reschedule, and cancel appointments. You are concise, confirm details before taking action, and always provide a clear summary after making changes.

# Usage Scenarios
scenarios:
  - id: check-availability
    title: User checks available time slots
    description: A user wants to see what times are open for a meeting.
    steps:
      - "User asks 'What times are available tomorrow?'"
      - Agent calls calendar.availability.check with the requested date
      - Agent presents available slots to the user
    expected_outcome: User sees a list of available time slots.
  - id: book-meeting
    title: User books a meeting
    description: A user picks a time slot and books a meeting.
    steps:
      - "User says 'Book a meeting tomorrow at 2pm with Dave'"
      - Agent calls calendar.event.create with the details
      - Agent confirms the booking with a summary
    expected_outcome: Meeting is created on Google Calendar.
  - id: reschedule-meeting
    title: User reschedules a meeting
    description: A user wants to move an existing meeting to a different time.
    steps:
      - "User says 'Reschedule my 2pm meeting to 4pm'"
      - Agent finds the meeting via calendar.event.list
      - Agent calls calendar.event.update with the new time
      - Agent confirms the change
    expected_outcome: Meeting is moved to the new time.
  - id: cancel-meeting
    title: User cancels a meeting
    description: A user wants to cancel an existing appointment.
    steps:
      - "User says 'Cancel my meeting with Dave tomorrow'"
      - Agent finds the meeting via calendar.event.list
      - Agent confirms the cancellation with the user
      - Agent calls calendar.event.delete
    expected_outcome: Meeting is removed from the calendar.

# Supported Intents
intents:
  supported:
    - id: check_availability
      description: User wants to see available time slots
      examples:
        - What times are available tomorrow?
        - When is Dave free this week?
        - Show me open slots for Friday
        - Are there any openings next Monday afternoon?
    - id: book_meeting
      description: User wants to book a new meeting or appointment
      examples:
        - Book a meeting tomorrow at 2pm
        - Schedule a call with Dave on Friday at 10am
        - "I'd like to set up a consultation next Tuesday"
        - Can you book me in for 3pm?
    - id: reschedule_meeting
      description: User wants to move an existing meeting to a different time
      examples:
        - Reschedule my 2pm meeting to 4pm
        - Move my meeting with Dave to next week
        - Can we push the 10am call to 11am?
        - "I need to change the time for tomorrow's appointment"
    - id: cancel_meeting
      description: User wants to cancel an existing meeting or appointment
      examples:
        - Cancel my meeting with Dave tomorrow
        - Delete the 3pm appointment
        - "I need to cancel tomorrow's call"
        - Remove the meeting on Friday

# Available Tools
tools:
  - id: tool-gcal-availability
    name: calendar.availability.check
    description: Check available time slots for a given date range.
    inputs:
      - name: date_start
        type: string
        required: true
        description: Start date in ISO 8601 format
      - name: date_end
        type: string
        required: false
        description: End date. Defaults to date_start.
      - name: participant_email
        type: string
        required: false
        description: Email of another participant to check mutual availability
    output:
      type: object
      description: List of available time slots
    policy:
      allowed: always
    security:
      classification: internal
  - id: tool-gcal-list
    name: calendar.event.list
    description: List calendar events for a date range.
    inputs:
      - name: date_start
        type: string
        required: true
        description: Start date in ISO 8601 format
      - name: date_end
        type: string
        required: false
        description: End date.
      - name: query
        type: string
        required: false
        description: Search query to filter events
    output:
      type: object
      description: List of calendar events
    policy:
      allowed: always
    security:
      classification: pii_read
  - id: tool-gcal-create
    name: calendar.event.create
    description: Create a new calendar event on Google Calendar.
    inputs:
      - name: title
        type: string
        required: true
        description: Event title
      - name: start_time
        type: string
        required: true
        description: Start time in ISO 8601
      - name: end_time
        type: string
        required: true
        description: End time in ISO 8601
      - name: attendees
        type: array
        required: false
        description: Attendee email addresses
      - name: description
        type: string
        required: false
        description: Event description
    output:
      type: object
      description: Created event with event_id and calendar link
    policy:
      allowed: conditional
    security:
      classification: pii_write
  - id: tool-gcal-update
    name: calendar.event.update
    description: Update an existing calendar event.
    inputs:
      - name: event_id
        type: string
        required: true
        description: ID of the event to update
      - name: title
        type: string
        required: false
        description: New title
      - name: start_time
        type: string
        required: false
        description: New start time
      - name: end_time
        type: string
        required: false
        description: New end time
      - name: attendees
        type: array
        required: false
        description: Updated attendee list
    output:
      type: object
      description: Updated event
    policy:
      allowed: conditional
    security:
      classification: pii_write
  - id: tool-gcal-delete
    name: calendar.event.delete
    description: Delete (cancel) a calendar event.
    inputs:
      - name: event_id
        type: string
        required: true
        description: Event ID to cancel
      - name: notify_attendees
        type: boolean
        required: false
        description: Whether to notify attendees
    output:
      type: object
      description: Cancellation confirmation
    policy:
      allowed: conditional
      requires_approval: always
    security:
      classification: destructive

# Policy & Guardrails
policy:
  guardrails:
    never:
      - Book meetings in the past
      - Delete events without user confirmation
      - "Access another user's calendar without their email"
      - Reveal internal event IDs to the user
    always:
      - Confirm meeting details before booking
      - Show a summary after any calendar change
      - Ask for clarification if date/time is ambiguous
  workflows:
    - name: Check Availability
      trigger: check_availability
      steps:
        - calendar.availability.check
        - sys.emitUserMessage
      required: false
    - name: Book Meeting
      trigger: book_meeting
      steps:
        - calendar.availability.check
        - sys.askUser
        - calendar.event.create
        - sys.emitUserMessage
      required: true
    - name: Reschedule
      trigger: reschedule_meeting
      steps:
        - calendar.event.list
        - calendar.availability.check
        - sys.askUser
        - calendar.event.update
        - sys.emitUserMessage
      required: true
    - name: Cancel Meeting
      trigger: cancel_meeting
      steps:
        - calendar.event.list
        - sys.askUser
        - calendar.event.delete
        - sys.emitUserMessage
      required: true
  approvals:
    - tool_id: tool-gcal-delete
      when: " > "
      approver: user

access_policy:
  rules:
    - tools: [calendar.event.list, calendar.availability.check]
      effect: allow
    - tools: [calendar.event.create, calendar.event.update, calendar.event.delete]
      effect: constrain

# Engine Configuration
engine:
  model: claude-sonnet-4-20250514
  temperature: 0.3
  max_tokens: 4096
  max_iterations: 10
  timeout: 60000
  on_max_iterations: ask_user
  finalization_gate:
    enabled: true
    max_retries: 2
  internal_error:
    enabled: true
    tool_not_found:
      enter_resolution_after: 1
      retryable: false
    resolution:
      max_iterations: 1
      allowed_capabilities: ["read", "search", "document_output"]
    loop_detection:
      enabled: true
      identical_call_threshold: 2
"""

@mcp.tool(name="calendar.availability.check")
def calendar_availability_check(date_start: str, date_end: str = None, participant_email: str = None) -> dict:
    """
    Tool description

    Args:
        date_start: Start date in ISO 8601 format
        date_end: End date. Defaults to date_start.
        participant_email: Email of another participant to check mutual availability

    Returns:
        List of available time slots
    """
    # Mock implementation for testing
    # TODO: Replace with actual logic
    mock_data = {
        {"date_start":"2026-02-18"}: {"date":"2026-02-18","available_slots":[{"start_time":"09:00","end_time":"10:00","duration_minutes":60},{"start_time":"14:00","end_time":"15:30","duration_minutes":90}],"timezone":"America/New_York"},
    }
    
    # Try to find matching mock data
    input_key = str({"date_start": date_start, "date_end": date_end, "participant_email": participant_email})
    if input_key in mock_data:
        return mock_data[input_key]
    
    # Default response if no mock match
    return {"date":"2026-02-18","available_slots":[{"start_time":"09:00","end_time":"10:00","duration_minutes":60},{"start_time":"14:00","end_time":"15:30","duration_minutes":90}],"timezone":"America/New_York","_note":"No matching mock data"}

@mcp.tool(name="calendar.event.list")
def calendar_event_list(date_start: str, date_end: str = None, query: str = None) -> dict:
    """
    Tool description

    Args:
        date_start: Start date in ISO 8601 format
        date_end: End date.
        query: Search query to filter events

    Returns:
        List of calendar events
    """
    # Mock implementation for testing
    # TODO: Replace with actual logic
    mock_data = {
        {"date_start":"2026-02-18"}: {"events":[{"event_id":"evt-001","title":"Team Standup","start_time":"2026-02-18T10:00:00","end_time":"2026-02-18T10:30:00"}]},
    }
    
    # Try to find matching mock data
    input_key = str({"date_start": date_start, "date_end": date_end, "query": query})
    if input_key in mock_data:
        return mock_data[input_key]
    
    # Default response if no mock match
    return {"events":[{"event_id":"evt-001","title":"Team Standup","start_time":"2026-02-18T10:00:00","end_time":"2026-02-18T10:30:00"}],"_note":"No matching mock data"}

@mcp.tool(name="calendar.event.create")
def calendar_event_create(title: str, start_time: str, end_time: str, attendees: list = None, description: str = None) -> dict:
    """
    Tool description

    Args:
        title: Event title
        start_time: Start time in ISO 8601
        end_time: End time in ISO 8601
        attendees: Attendee email addresses
        description: Event description

    Returns:
        Created event with event_id and calendar link
    """
    # Mock implementation for testing
    # TODO: Replace with actual logic
    mock_data = {
        {"title":"Meeting with Dave","start_time":"2026-02-18T14:00:00","end_time":"2026-02-18T15:00:00"}: {"event_id":"evt-new-001","title":"Meeting with Dave","status":"confirmed"},
    }
    
    # Try to find matching mock data
    input_key = str({"title": title, "start_time": start_time, "end_time": end_time, "attendees": attendees, "description": description})
    if input_key in mock_data:
        return mock_data[input_key]
    
    # Default response if no mock match
    return {"event_id":"evt-new-001","title":"Meeting with Dave","status":"confirmed","_note":"No matching mock data"}

@mcp.tool(name="calendar.event.update")
def calendar_event_update(event_id: str, title: str = None, start_time: str = None, end_time: str = None, attendees: list = None) -> dict:
    """
    Tool description

    Args:
        event_id: ID of the event to update
        title: New title
        start_time: New start time
        end_time: New end time
        attendees: Updated attendee list

    Returns:
        Updated event
    """
    # Mock implementation for testing
    # TODO: Replace with actual logic
    mock_data = {
        {"event_id":"evt-001","start_time":"2026-02-18T16:00:00"}: {"event_id":"evt-001","status":"updated"},
    }
    
    # Try to find matching mock data
    input_key = str({"event_id": event_id, "title": title, "start_time": start_time, "end_time": end_time, "attendees": attendees})
    if input_key in mock_data:
        return mock_data[input_key]
    
    # Default response if no mock match
    return {"event_id":"evt-001","status":"updated","_note":"No matching mock data"}

@mcp.tool(name="calendar.event.delete")
def calendar_event_delete(event_id: str, notify_attendees: bool = None) -> dict:
    """
    Tool description

    Args:
        event_id: Event ID to cancel
        notify_attendees: Whether to notify attendees

    Returns:
        Cancellation confirmation
    """
    # Mock implementation for testing
    # TODO: Replace with actual logic
    mock_data = {
        {"event_id":"evt-002"}: {"event_id":"evt-002","status":"cancelled"},
    }
    
    # Try to find matching mock data
    input_key = str({"event_id": event_id, "notify_attendees": notify_attendees})
    if input_key in mock_data:
        return mock_data[input_key]
    
    # Default response if no mock match
    return {"event_id":"evt-002","status":"cancelled","_note":"No matching mock data"}

@mcp.tool()
def get_skill_definition() -> dict:
    """Get the complete skill definition YAML for ADAS Core installation.

    Returns the full skill configuration including problem statement,
    tool definitions, policy, guardrails, engine config, ui_plugins,
    and external connector references.
    """
    return {
        "format": "yaml",
        "content": SKILL_DEFINITION_YAML.strip(),
        "skill_name": "Scheduling Agent",
        "version": "1.0.0"
    }

@mcp.tool()
def health_check() -> dict:
    """Check server health."""
    return {"status": "healthy", "server": "Scheduling Agent"}

if __name__ == "__main__":
    import os
    transport = os.environ.get("MCP_TRANSPORT", "sse")
    port = int(os.environ.get("MCP_PORT", "8100"))
    host = os.environ.get("MCP_HOST", "0.0.0.0")

    if transport == "sse":
        import uvicorn
        uvicorn.run(mcp.sse_app(), host=host, port=port)
    else:
        mcp.run()
