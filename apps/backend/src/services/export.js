/**
 * Generate MCP server code from toolbox definition
 */

export function generateMCPServer(toolbox) {
  const tools = toolbox.tools || [];
  const name = toolbox.problem?.statement || "My Toolbox";
  
  // Generate tool functions
  const toolFunctions = tools.map(tool => generateToolFunction(tool)).join("\n\n");
  
  return `"""
MCP Server: ${name}
Generated by ADAS MCP Toolbox Builder
Version: ${toolbox.version || 1}
"""

from mcp.server.fastmcp import FastMCP

mcp = FastMCP("${escapeString(name)}")

${toolFunctions}

if __name__ == "__main__":
    mcp.run()
`;
}

function generateToolFunction(tool) {
  const inputs = tool.inputs || [];
  const output = tool.output || {};
  const mock = tool.mock || {};
  
  // Generate function signature
  const params = inputs.map(inp => {
    const typeHint = pythonType(inp.type);
    if (inp.required === false) {
      return `${inp.name}: ${typeHint} = None`;
    }
    return `${inp.name}: ${typeHint}`;
  }).join(", ");
  
  // Generate docstring
  const docstring = generateDocstring(tool);
  
  // Generate mock implementation
  const mockImpl = generateMockImplementation(tool);
  
  return `@mcp.tool()
def ${tool.name}(${params}) -> dict:
${docstring}
${mockImpl}`;
}

function generateDocstring(tool) {
  const lines = [`    """`, `    ${tool.purpose || "Tool description"}`];
  
  if (tool.inputs?.length > 0) {
    lines.push("");
    lines.push("    Args:");
    for (const inp of tool.inputs) {
      lines.push(`        ${inp.name}: ${inp.description || inp.type}`);
    }
  }
  
  if (tool.output) {
    lines.push("");
    lines.push("    Returns:");
    lines.push(`        ${tool.output.description || "Result object"}`);
  }
  
  lines.push(`    """`);
  return lines.join("\n");
}

function generateMockImplementation(tool) {
  const mock = tool.mock || {};
  const examples = mock.examples || [];
  
  if (examples.length === 0) {
    return `    # TODO: Implement actual logic
    return {"status": "not_implemented"}`;
  }
  
  // Generate mock data lookup
  const lines = [
    "    # Mock implementation for testing",
    "    # TODO: Replace with actual logic",
    "    mock_data = {"
  ];
  
  for (const example of examples) {
    const key = JSON.stringify(example.input);
    const value = JSON.stringify(example.output);
    lines.push(`        ${key}: ${value},`);
  }
  
  lines.push("    }");
  lines.push("");
  lines.push("    # Try to find matching mock data");
  lines.push(`    input_key = ${generateInputKey(tool.inputs)}`);
  lines.push("    if input_key in mock_data:");
  lines.push("        return mock_data[input_key]");
  lines.push("");
  lines.push("    # Default response if no mock match");
  
  // Use first example output as template
  if (examples[0]?.output) {
    const defaultOutput = { ...examples[0].output, _note: "No matching mock data" };
    lines.push(`    return ${JSON.stringify(defaultOutput)}`);
  } else {
    lines.push(`    return {"error": "No matching mock data"}`);
  }
  
  return lines.map(l => "    " + l.slice(4)).join("\n");
}

function generateInputKey(inputs) {
  if (!inputs || inputs.length === 0) {
    return '"{}"';
  }
  
  const parts = inputs.map(inp => `"${inp.name}": ${inp.name}`).join(", ");
  return `str({${parts}})`;
}

function pythonType(type) {
  switch (type?.toLowerCase()) {
    case "string":
    case "text":
      return "str";
    case "number":
    case "integer":
    case "int":
      return "int";
    case "float":
    case "decimal":
      return "float";
    case "boolean":
    case "bool":
      return "bool";
    case "array":
    case "list":
      return "list";
    case "object":
    case "dict":
      return "dict";
    default:
      return "str";
  }
}

function escapeString(str) {
  return (str || "").replace(/"/g, '\\"').replace(/\n/g, "\\n");
}

/**
 * Generate requirements.txt
 */
export function generateRequirements() {
  return `mcp>=0.1.0
fastmcp>=0.1.0
`;
}

/**
 * Generate Dockerfile
 */
export function generateDockerfile() {
  return `FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY mcp_server.py .

EXPOSE 8000

CMD ["python", "mcp_server.py"]
`;
}

/**
 * Generate README
 */
export function generateReadme(toolbox) {
  const name = toolbox.problem?.statement || "My Toolbox";
  const tools = toolbox.tools || [];
  
  const toolList = tools.map((t, i) => 
    `${i + 1}. **${t.name}** - ${t.purpose || "No description"}`
  ).join("\n");
  
  return `# ${name} - MCP Server

Generated by ADAS MCP Toolbox Builder.

## Tools Included

${toolList}

## Setup

### Option 1: Run Locally

\`\`\`bash
pip install -r requirements.txt
python mcp_server.py
\`\`\`

### Option 2: Run with Docker

\`\`\`bash
docker build -t ${toSlug(name)}-mcp .
docker run -p 8000:8000 ${toSlug(name)}-mcp
\`\`\`

### Option 3: Add to Claude Desktop

Add to your Claude Desktop config (\`~/.claude/config.json\`):

\`\`\`json
{
  "mcpServers": {
    "${toSlug(name)}": {
      "command": "python",
      "args": ["/path/to/mcp_server.py"]
    }
  }
}
\`\`\`

## Customization

The generated code includes mock implementations based on your examples.
Replace the mock logic with actual implementations for production use.
`;
}

/**
 * Generate Claude Desktop config snippet
 */
export function generateClaudeConfig(toolbox) {
  const name = toolbox.problem?.statement || "My Toolbox";
  const slug = toSlug(name);
  
  return JSON.stringify({
    mcpServers: {
      [slug]: {
        command: "python",
        args: ["mcp_server.py"]
      }
    }
  }, null, 2);
}

function toSlug(str) {
  return (str || "toolbox")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "")
    .slice(0, 30);
}

/**
 * Generate domain.yaml - Complete domain configuration
 */
export function generateDomainYaml(domain) {
  const lines = [];

  // Header
  lines.push(`# Domain Configuration`);
  lines.push(`# Generated by ADAS MCP Toolbox Builder`);
  lines.push(`# Version: ${domain.version || 1}`);
  lines.push(``);

  // Basic info
  lines.push(`id: ${yamlString(domain.id || toSlug(domain.name || 'untitled'))}`);
  lines.push(`name: ${yamlString(domain.name || 'Untitled Domain')}`);
  lines.push(`version: ${domain.version || 1}`);
  lines.push(`phase: ${domain.phase || 'DRAFT'}`);
  lines.push(``);

  // MCP Server for skill-specific tools (Multi-Slag Architecture)
  if (domain.mcp_server) {
    lines.push(`# MCP Server for skill-specific tools`);
    lines.push(`mcp_server: ${yamlString(domain.mcp_server)}`);
    lines.push(``);
  }


  // Problem
  lines.push(`# Problem Definition`);
  lines.push(`problem:`);
  lines.push(`  statement: ${yamlString(domain.problem?.statement || '')}`);
  if (domain.problem?.context) {
    lines.push(`  context: ${yamlString(domain.problem.context)}`);
  }
  if (domain.problem?.goals?.length > 0) {
    lines.push(`  goals:`);
    for (const goal of domain.problem.goals) {
      lines.push(`    - ${yamlString(goal)}`);
    }
  }
  lines.push(``);

  // Role
  if (domain.role?.name || domain.role?.persona) {
    lines.push(`# Agent Role`);
    lines.push(`role:`);
    if (domain.role.name) lines.push(`  name: ${yamlString(domain.role.name)}`);
    if (domain.role.persona) lines.push(`  persona: ${yamlString(domain.role.persona)}`);
    lines.push(``);
  }

  // Top-level persona for Core ADAS Reply Polisher
  if (domain.role?.persona) {
    lines.push(`# Persona (top-level for Core ADAS)`);
    lines.push(`persona: ${yamlString(domain.role.persona)}`);
    lines.push(``);
  }

  // Scenarios
  if (domain.scenarios?.length > 0) {
    lines.push(`# Usage Scenarios`);
    lines.push(`scenarios:`);
    for (const scenario of domain.scenarios) {
      lines.push(`  - id: ${scenario.id || ''}`);
      lines.push(`    title: ${yamlString(scenario.title || '')}`);
      if (scenario.description) {
        lines.push(`    description: ${yamlString(scenario.description)}`);
      }
      if (scenario.steps?.length > 0) {
        lines.push(`    steps:`);
        for (const step of scenario.steps) {
          lines.push(`      - ${yamlString(step)}`);
        }
      }
      if (scenario.expected_outcome) {
        lines.push(`    expected_outcome: ${yamlString(scenario.expected_outcome)}`);
      }
    }
    lines.push(``);
  }

  // Intents
  if (domain.intents?.supported?.length > 0) {
    lines.push(`# Supported Intents`);
    lines.push(`intents:`);
    lines.push(`  supported:`);
    for (const intent of domain.intents.supported) {
      lines.push(`    - id: ${intent.id || ''}`);
      lines.push(`      description: ${yamlString(intent.description || '')}`);
      if (intent.examples?.length > 0) {
        lines.push(`      examples:`);
        for (const example of intent.examples) {
          lines.push(`        - ${yamlString(example)}`);
        }
      }
      if (intent.entities?.length > 0) {
        lines.push(`      entities:`);
        for (const entity of intent.entities) {
          lines.push(`        - name: ${entity.name}`);
          lines.push(`          type: ${entity.type || 'string'}`);
          lines.push(`          required: ${entity.required !== false}`);
        }
      }
    }
    // Out of domain handling
    if (domain.intents.out_of_domain) {
      lines.push(`  out_of_domain:`);
      lines.push(`    action: ${domain.intents.out_of_domain.action || 'redirect'}`);
      if (domain.intents.out_of_domain.message) {
        lines.push(`    message: ${yamlString(domain.intents.out_of_domain.message)}`);
      }
    }
    lines.push(``);
  }

  // Tools (including compiled meta tools)
  // Meta tools are "compiled" into regular tools at export time
  // This way ADAS Core sees them as normal tools - no special handling needed
  const approvedMetaTools = (domain.meta_tools || []).filter(mt => mt.status === 'approved');
  const allTools = [...(domain.tools || [])];

  // Convert meta tools to regular tools
  for (const metaTool of approvedMetaTools) {
    // Collect inputs from all composed tools (deduplicated)
    const composedToolNames = metaTool.composes || [];
    const composedTools = composedToolNames
      .map(name => domain.tools?.find(t => t.name === name))
      .filter(Boolean);

    // Gather unique inputs from all composed tools
    const inputMap = new Map();
    for (const composedTool of composedTools) {
      for (const input of (composedTool.inputs || [])) {
        if (!inputMap.has(input.name)) {
          inputMap.set(input.name, input);
        }
      }
    }

    // Create the meta tool as a regular tool
    const metaAsRegularTool = {
      id: metaTool.id,
      name: metaTool.name,
      description: `${metaTool.description}${metaTool.logic ? ` (Logic: ${metaTool.logic})` : ''}`,
      inputs: Array.from(inputMap.values()),
      output: {
        type: 'object',
        description: `Combined result from: ${composedToolNames.join(', ')}`
      },
      policy: {
        allowed: 'always',
        requires_approval: 'never'
      },
      // Mark as composition for documentation
      _meta: {
        is_composition: true,
        composes: composedToolNames,
        logic: metaTool.logic
      }
    };

    allTools.push(metaAsRegularTool);
  }

  if (allTools.length > 0) {
    lines.push(`# Available Tools`);
    if (approvedMetaTools.length > 0) {
      lines.push(`# Note: Includes ${approvedMetaTools.length} meta tool(s) compiled as regular tools`);
    }
    lines.push(`tools:`);
    for (const tool of allTools) {
      lines.push(`  - id: ${tool.id || ''}`);
      lines.push(`    name: ${yamlString(tool.name || '')}`);
      lines.push(`    description: ${yamlString(tool.description || '')}`);

      // Inputs
      if (tool.inputs?.length > 0) {
        lines.push(`    inputs:`);
        for (const input of tool.inputs) {
          lines.push(`      - name: ${input.name}`);
          lines.push(`        type: ${input.type || 'string'}`);
          lines.push(`        required: ${input.required !== false}`);
          if (input.description) {
            lines.push(`        description: ${yamlString(input.description)}`);
          }
        }
      }

      // Output
      if (tool.output) {
        lines.push(`    output:`);
        lines.push(`      type: ${tool.output.type || 'object'}`);
        if (tool.output.description) {
          lines.push(`      description: ${yamlString(tool.output.description)}`);
        }
        if (tool.output.fields?.length > 0) {
          lines.push(`      fields:`);
          for (const field of tool.output.fields) {
            lines.push(`        - name: ${field.name}`);
            lines.push(`          type: ${field.type || 'string'}`);
            if (field.description) {
              lines.push(`          description: ${yamlString(field.description)}`);
            }
          }
        }
      }

      // Policy
      if (tool.policy) {
        lines.push(`    policy:`);
        lines.push(`      allowed: ${tool.policy.allowed || 'always'}`);
        if (tool.policy.requires_approval) {
          lines.push(`      requires_approval: ${tool.policy.requires_approval}`);
        }
        if (tool.policy.condition) {
          lines.push(`      condition: ${yamlString(tool.policy.condition)}`);
        }
      }

      // Composition metadata (for documentation/debugging)
      if (tool._meta?.is_composition) {
        lines.push(`    # Meta tool - composes: ${tool._meta.composes.join(', ')}`);
      }
    }
    lines.push(``);
  }

  // Policy
  lines.push(`# Policy & Guardrails`);
  lines.push(`policy:`);

  // Guardrails
  lines.push(`  guardrails:`);
  const neverRules = domain.policy?.guardrails?.never || [];
  const alwaysRules = domain.policy?.guardrails?.always || [];

  lines.push(`    never:`);
  if (neverRules.length > 0) {
    for (const rule of neverRules) {
      lines.push(`      - ${yamlString(rule)}`);
    }
  } else {
    lines.push(`      []`);
  }

  lines.push(`    always:`);
  if (alwaysRules.length > 0) {
    for (const rule of alwaysRules) {
      lines.push(`      - ${yamlString(rule)}`);
    }
  } else {
    lines.push(`      []`);
  }

  // Escalation
  if (domain.policy?.escalation) {
    lines.push(`  escalation:`);
    lines.push(`    enabled: ${domain.policy.escalation.enabled || false}`);
    if (domain.policy.escalation.conditions?.length > 0) {
      lines.push(`    conditions:`);
      for (const cond of domain.policy.escalation.conditions) {
        lines.push(`      - ${yamlString(cond)}`);
      }
    }
  }

  // Workflows
  if (domain.policy?.workflows?.length > 0) {
    lines.push(`  workflows:`);
    for (const wf of domain.policy.workflows) {
      lines.push(`    - name: ${yamlString(wf.name || '')}`);
      if (wf.trigger) lines.push(`      trigger: ${yamlString(wf.trigger)}`);
      if (wf.steps?.length > 0) {
        lines.push(`      steps:`);
        for (const step of wf.steps) {
          lines.push(`        - ${yamlString(step)}`);
        }
      }
      lines.push(`      required: ${wf.required || false}`);
    }
  }

  // Approvals (for Core ADAS checkApprovalRequired)
  if (domain.policy?.approvals?.length > 0) {
    lines.push(`  approvals:`);
    for (const approval of domain.policy.approvals) {
      lines.push(`    - tool_id: ${approval.tool_id || ''}`);
      // Convert conditions array to "when" string if present
      if (approval.conditions?.length > 0) {
        const whenParts = approval.conditions.map(c =>
          `${c.field || ''} ${c.operator || '>'} ${c.value || ''}`
        );
        lines.push(`      when: ${yamlString(whenParts.join(' AND '))}`);
      } else if (approval.when) {
        lines.push(`      when: ${yamlString(approval.when)}`);
      }
      if (approval.approver) {
        lines.push(`      approver: ${approval.approver}`);
      }
    }
  }
  lines.push(``);

  // Engine settings
  lines.push(`# Engine Configuration`);
  lines.push(`engine:`);
  lines.push(`  model: ${domain.engine?.model || 'default'}`);
  lines.push(`  temperature: ${domain.engine?.temperature ?? 0.7}`);
  lines.push(`  max_tokens: ${domain.engine?.max_tokens || 4096}`);
  if (domain.engine?.response_format) {
    lines.push(`  response_format: ${domain.engine.response_format}`);
  }
  // Finalization Gate config (for Core ADAS)
  lines.push(`  finalization_gate:`);
  lines.push(`    enabled: ${domain.engine?.finalization_gate?.enabled ?? true}`);
  lines.push(`    max_retries: ${domain.engine?.finalization_gate?.max_retries ?? 2}`);

  // Output Contract (for Core ADAS Finalization Gate)
  if (domain.output_contract?.required_fields?.length > 0) {
    lines.push(``);
    lines.push(`# Output Contract`);
    lines.push(`output_contract:`);
    lines.push(`  required_fields:`);
    for (const field of domain.output_contract.required_fields) {
      lines.push(`    - ${yamlString(field)}`);
    }
  }

  return lines.join('\n');
}

/**
 * Helper to escape YAML strings
 */
function yamlString(str) {
  if (str === null || str === undefined) return '""';
  const s = String(str);
  // If contains special chars or newlines, quote it
  if (s.includes(':') || s.includes('#') || s.includes('\n') || s.includes('"') || s.includes("'") || s.startsWith(' ') || s.endsWith(' ')) {
    // Use double quotes and escape internal quotes
    return `"${s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n')}"`;
  }
  return s || '""';
}

/**
 * Generate a single JS tool file (.mjs) for ADAS Core
 */
function generateJSTool(tool) {
  const inputs = tool.inputs || [];
  const mock = tool.mock || {};
  const examples = mock.examples || [];

  // Generate JSDoc for args
  const argsDoc = inputs.map(inp => {
    const optional = inp.required === false ? " (optional)" : "";
    return ` * @param {${jsType(inp.type)}} args.${inp.name} - ${inp.description || inp.type}${optional}`;
  }).join("\n");

  // Generate mock implementation
  let mockImpl;
  if (examples.length > 0) {
    const mockData = examples.map(ex => {
      const key = JSON.stringify(ex.input);
      const val = JSON.stringify(ex.output, null, 2).split("\n").map((l, i) => i > 0 ? "    " + l : l).join("\n");
      return `  [${key}, ${val}]`;
    }).join(",\n");

    mockImpl = `  // Mock data for testing
  const mockData = new Map([
${mockData}
  ]);

  // Try to find matching mock
  const inputKey = JSON.stringify(args);
  for (const [key, value] of mockData) {
    if (key === inputKey) {
      return { ok: true, ...value };
    }
  }

  // Default response
  return { ok: true, _note: "No matching mock data", args };`;
  } else {
    mockImpl = `  // TODO: Implement actual logic
  return { ok: false, error: "Not implemented", args };`;
  }

  // Generate meta args array
  const metaArgs = inputs.map(inp => {
    return `    { name: "${inp.name}", type: "${inp.type || "string"}", optional: ${inp.required === false}, description: "${escapeString(inp.description || "")}" }`;
  }).join(",\n");

  return `// ${tool.name}.mjs - Generated by ADAS MCP Toolbox Builder
// Tool: ${tool.purpose || tool.name}

/**
 * ${tool.purpose || tool.name}
 *
${argsDoc || " * @param {object} args - Tool arguments"}
 * @param {object} job - Job context
 * @returns {Promise<object>} Tool result
 */
async function ${tool.name}(args, job) {
${mockImpl}
}

${tool.name}.meta = {
  name: "${tool.name}",
  description: "${escapeString(tool.purpose || "")}",
  args: [
${metaArgs}
  ],
  planner: { visible: true }
};

export default ${tool.name};
`;
}

/**
 * Convert toolbox type to JS type for JSDoc
 */
function jsType(type) {
  switch (type?.toLowerCase()) {
    case "string":
    case "text":
      return "string";
    case "number":
    case "integer":
    case "int":
    case "float":
    case "decimal":
      return "number";
    case "boolean":
    case "bool":
      return "boolean";
    case "array":
    case "list":
      return "Array";
    case "object":
    case "dict":
      return "object";
    default:
      return "string";
  }
}

/**
 * Generate skill.yaml for ADAS Core (simplified from domain.yaml)
 */
export function generateSkillYaml(toolbox) {
  const lines = [];
  const slug = toSlug(toolbox.name || toolbox.id || "untitled");

  lines.push(`# Skill Configuration for ADAS Core`);
  lines.push(`# Generated by ADAS MCP Toolbox Builder`);
  lines.push(``);
  lines.push(`id: ${yamlString(slug)}`);
  lines.push(`name: ${yamlString(toolbox.name || "Untitled Skill")}`);
  lines.push(`version: ${toolbox.version || 1}`);
  lines.push(``);

  // Resources
  lines.push(`resources:`);
  lines.push(`  - name: codebase`);
  lines.push(`    type: filesystem`);
  lines.push(`    required: false`);
  lines.push(`    description: "Project source code directory"`);
  lines.push(``);

  // Role/Persona
  if (toolbox.role?.persona) {
    lines.push(`role:`);
    lines.push(`  persona: |`);
    const personaLines = toolbox.role.persona.split("\n");
    for (const line of personaLines) {
      lines.push(`    ${line}`);
    }
    lines.push(``);
  }

  // Policy - allow all tools by default
  lines.push(`policy:`);
  lines.push(`  tools:`);
  lines.push(`    allowed: ["*"]`);
  lines.push(``);

  return lines.join("\n");
}

/**
 * Generate a JS meta tool with precise execution instructions
 *
 * Meta tools are higher-level operations that combine multiple tools.
 * The description is precise so the LLM/Python script knows exactly what to call.
 */
function generateJSMetaTool(metaTool, composedTools) {
  const composedToolNames = metaTool.composes || [];

  // Gather unique inputs from all composed tools
  const inputMap = new Map();
  for (const composedTool of composedTools) {
    for (const input of (composedTool.inputs || [])) {
      if (!inputMap.has(input.name)) {
        inputMap.set(input.name, input);
      }
    }
  }
  const inputs = Array.from(inputMap.values());

  // Generate JSDoc for args
  const argsDoc = inputs.map(inp => {
    const optional = inp.required === false ? " (optional)" : "";
    return ` * @param {${jsType(inp.type)}} args.${inp.name} - ${inp.description || inp.type}${optional}`;
  }).join("\n");

  // Generate meta args array
  const metaArgs = inputs.map(inp => {
    return `    { name: "${inp.name}", type: "${inp.type || "string"}", optional: ${inp.required === false}, description: "${escapeString(inp.description || "")}" }`;
  }).join(",\n");

  // Meta description - describes WHAT it does (like a real tool)
  const toolDescription = escapeString(metaTool.description);

  // Generate tool call sequence
  // Each composed tool is called via deps.tools
  const toolCalls = composedToolNames.map((name, i) => {
    return `  const result_${i} = await deps.tools.${name}(args, job, deps);
  results.${name} = result_${i};
  if (result_${i}?.ok === false) {
    return { ok: false, error: \`Tool ${name} failed: \${result_${i}?.error || 'unknown'}\`, results };
  }`;
  }).join("\n\n");

  return `// ${metaTool.name}.mjs - Generated by ADAS MCP Toolbox Builder
// Meta Tool: Composes ${composedToolNames.join(' + ')}

/**
 * ${metaTool.description}
 *
${argsDoc || " * @param {object} args - Tool arguments"}
 * @param {object} job - Job context
 * @param {object} deps - Dependencies (includes deps.tools for calling other tools)
 * @returns {Promise<object>} Combined result from composed tools
 */
async function ${metaTool.name}(args = {}, job = {}, deps = {}) {
  const results = {};

  // Logic: ${metaTool.logic || 'Run tools in sequence'}
${toolCalls}

  return { ok: true, results };
}

${metaTool.name}.meta = {
  name: "${metaTool.name}",
  description: "${toolDescription}",
  args: [
${metaArgs}
  ],
  planner: { visible: true }
};

export default ${metaTool.name};
`;
}

/**
 * Get all tools including compiled meta tools
 */
function getAllToolsWithMetaCompiled(toolbox) {
  const tools = [...(toolbox.tools || [])];
  const approvedMetaTools = (toolbox.meta_tools || []).filter(mt => mt.status === 'approved');

  // Convert meta tools to tool-like objects for code generation
  const metaToolsAsTools = approvedMetaTools.map(metaTool => {
    const composedToolNames = metaTool.composes || [];
    const composedTools = composedToolNames
      .map(name => toolbox.tools?.find(t => t.name === name))
      .filter(Boolean);

    // Gather unique inputs
    const inputMap = new Map();
    for (const composedTool of composedTools) {
      for (const input of (composedTool.inputs || [])) {
        if (!inputMap.has(input.name)) {
          inputMap.set(input.name, input);
        }
      }
    }

    return {
      ...metaTool,
      inputs: Array.from(inputMap.values()),
      output: {
        type: 'object',
        description: `Combined result from: ${composedToolNames.join(', ')}`
      },
      _isMetaTool: true,
      _composedTools: composedTools
    };
  });

  return { tools, metaToolsAsTools, approvedMetaTools };
}

/**
 * Generate export payload for ADAS Core import API
 * This creates the JSON structure expected by POST /api/skills/import
 *
 * NOTE: Meta tools are NOT exported as separate .mjs files.
 * They exist only as descriptions in domain.yaml so the planner knows about them.
 * The planner will call the composed tools directly based on the description.
 */
export function generateAdasExportPayload(toolbox) {
  const slug = toSlug(toolbox.name || toolbox.id || "untitled");
  const tools = toolbox.tools || [];
  const approvedMetaTools = (toolbox.meta_tools || []).filter(mt => mt.status === 'approved');

  // Build skill object (what goes in skill.yaml)
  const skill = {
    id: slug,
    name: toolbox.name || "Untitled Skill",
    version: toolbox.version || 1,
    resources: [
      { name: "codebase", type: "filesystem", required: false, description: "Project source code directory" }
    ],
    policy: {
      tools: { allowed: ["*"] }
    }
  };

  if (toolbox.role?.persona) {
    skill.role = { persona: toolbox.role.persona };
  }

  // Build tools array with name and code (regular tools)
  const toolsPayload = tools.map(tool => ({
    name: tool.name,
    code: generateJSTool(tool)
  }));

  // Add meta tools as .mjs files - they return execution instructions
  for (const metaTool of approvedMetaTools) {
    const composedTools = (metaTool.composes || [])
      .map(name => tools.find(t => t.name === name))
      .filter(Boolean);

    toolsPayload.push({
      name: metaTool.name,
      code: generateJSMetaTool(metaTool, composedTools)
    });
  }

  return {
    skillSlug: slug,
    skill,
    tools: toolsPayload
  };
}

/**
 * Generate all export files (original MCP format)
 */
export function generateExportFiles(toolbox) {
  return [
    { name: "domain.yaml", content: generateDomainYaml(toolbox) },
    { name: "mcp_server.py", content: generateMCPServer(toolbox) },
    { name: "requirements.txt", content: generateRequirements() },
    { name: "Dockerfile", content: generateDockerfile() },
    { name: "README.md", content: generateReadme(toolbox) },
    { name: "claude_desktop_config.json", content: generateClaudeConfig(toolbox) }
  ];
}

/**
 * Generate export files for ADAS Core (JS tools format)
 *
 * Meta tools ARE exported as .mjs files that return execution instructions.
 * Core calls them like regular tools, but they return directives instead of results.
 */
export function generateAdasExportFiles(toolbox) {
  const tools = toolbox.tools || [];
  const approvedMetaTools = (toolbox.meta_tools || []).filter(mt => mt.status === 'approved');
  const files = [
    { name: "skill.yaml", content: generateSkillYaml(toolbox) }
  ];

  // Add each regular tool as a separate .mjs file
  for (const tool of tools) {
    files.push({
      name: `tools/${tool.name}.mjs`,
      content: generateJSTool(tool)
    });
  }

  // Add meta tools as .mjs files - they return execution instructions
  for (const metaTool of approvedMetaTools) {
    const composedTools = (metaTool.composes || [])
      .map(name => tools.find(t => t.name === name))
      .filter(Boolean);

    files.push({
      name: `tools/${metaTool.name}.mjs`,
      content: generateJSMetaTool(metaTool, composedTools)
    });
  }

  return files;
}

export default {
  generateMCPServer,
  generateRequirements,
  generateDockerfile,
  generateReadme,
  generateClaudeConfig,
  generateDomainYaml,
  generateExportFiles,
  // ADAS Core export functions
  generateSkillYaml,
  generateAdasExportPayload,
  generateAdasExportFiles
};
