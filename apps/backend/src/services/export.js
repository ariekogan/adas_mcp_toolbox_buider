import { generateAllConnectorFiles } from './exportConnectorTemplate.js';
import { getAllPrebuiltConnectors } from '../routes/connectors.js';

/**
 * Generate MCP server code from toolbox definition
 */

export function generateMCPServer(toolbox) {
  const tools = toolbox.tools || [];
  const name = toolbox.problem?.statement || "My Toolbox";
  
  // Generate tool functions
  const toolFunctions = tools.map(tool => generateToolFunction(tool)).join("\n\n");
  
  return `"""
MCP Server: ${name}
Generated by ADAS MCP Toolbox Builder
Version: ${toolbox.version || 1}
"""

from mcp.server.fastmcp import FastMCP

mcp = FastMCP("${escapeString(name)}")

${toolFunctions}

if __name__ == "__main__":
    import os
    transport = os.environ.get("MCP_TRANSPORT", "sse")
    port = int(os.environ.get("MCP_PORT", "8100"))
    host = os.environ.get("MCP_HOST", "0.0.0.0")

    if transport == "sse":
        import uvicorn
        uvicorn.run(mcp.sse_app(), host=host, port=port)
    else:
        mcp.run()
`;
}

function generateToolFunction(tool) {
  const inputs = tool.inputs || [];
  const output = tool.output || {};
  const mock = tool.mock || {};
  
  // Generate function signature - required params first, then optional
  const requiredParams = inputs.filter(inp => inp.required !== false);
  const optionalParams = inputs.filter(inp => inp.required === false);
  const sortedInputs = [...requiredParams, ...optionalParams];

  const params = sortedInputs.map(inp => {
    const typeHint = pythonType(inp.type);
    if (inp.required === false) {
      return `${inp.name}: ${typeHint} = None`;
    }
    return `${inp.name}: ${typeHint}`;
  }).join(", ");
  
  // Generate docstring
  const docstring = generateDocstring(tool);
  
  // Generate mock implementation
  const mockImpl = generateMockImplementation(tool);
  
  // Sanitize tool name to be a valid Python identifier
  const pythonName = sanitizePythonName(tool.name);

  // Use name= parameter to preserve the original dotted tool name for MCP
  const decorator = pythonName !== tool.name
    ? `@mcp.tool(name="${tool.name}")`
    : `@mcp.tool()`;

  return `${decorator}
def ${pythonName}(${params}) -> dict:
${docstring}
${mockImpl}`;
}

function generateDocstring(tool) {
  const lines = [`    """`, `    ${tool.purpose || "Tool description"}`];
  
  if (tool.inputs?.length > 0) {
    lines.push("");
    lines.push("    Args:");
    for (const inp of tool.inputs) {
      lines.push(`        ${inp.name}: ${inp.description || inp.type}`);
    }
  }
  
  if (tool.output) {
    lines.push("");
    lines.push("    Returns:");
    lines.push(`        ${tool.output.description || "Result object"}`);
  }
  
  lines.push(`    """`);
  return lines.join("\n");
}

function generateMockImplementation(tool) {
  const mock = tool.mock || {};
  const examples = mock.examples || [];
  
  if (examples.length === 0) {
    return `    # TODO: Implement actual logic
    return {"status": "not_implemented"}`;
  }
  
  // Generate mock data lookup
  const lines = [
    "    # Mock implementation for testing",
    "    # TODO: Replace with actual logic",
    "    mock_data = {"
  ];
  
  for (const example of examples) {
    // Skip examples with undefined input or output
    if (example.input === undefined || example.output === undefined) {
      continue;
    }
    const key = JSON.stringify(example.input);
    const value = JSON.stringify(example.output);
    lines.push(`        ${key}: ${value},`);
  }
  
  lines.push("    }");
  lines.push("");
  lines.push("    # Try to find matching mock data");
  lines.push(`    input_key = ${generateInputKey(tool.inputs)}`);
  lines.push("    if input_key in mock_data:");
  lines.push("        return mock_data[input_key]");
  lines.push("");
  lines.push("    # Default response if no mock match");
  
  // Use first example output as template
  if (examples[0]?.output) {
    const defaultOutput = { ...examples[0].output, _note: "No matching mock data" };
    lines.push(`    return ${JSON.stringify(defaultOutput)}`);
  } else {
    lines.push(`    return {"error": "No matching mock data"}`);
  }
  
  return lines.map(l => "    " + l.slice(4)).join("\n");
}

function generateInputKey(inputs) {
  if (!inputs || inputs.length === 0) {
    return '"{}"';
  }
  
  const parts = inputs.map(inp => `"${inp.name}": ${inp.name}`).join(", ");
  return `str({${parts}})`;
}

function pythonType(type) {
  switch (type?.toLowerCase()) {
    case "string":
    case "text":
      return "str";
    case "number":
    case "integer":
    case "int":
      return "int";
    case "float":
    case "decimal":
      return "float";
    case "boolean":
    case "bool":
      return "bool";
    case "array":
    case "list":
      return "list";
    case "object":
    case "dict":
      return "dict";
    default:
      return "str";
  }
}

function escapeString(str) {
  return (str || "").replace(/"/g, '\\"').replace(/\n/g, "\\n");
}

/**
 * Sanitize a name to be a valid Python identifier
 */
function sanitizePythonName(name) {
  if (!name) return "unnamed_tool";
  // Replace dots, spaces and hyphens with underscores, remove other invalid chars
  let sanitized = name.replace(/[.\s-]+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
  // Ensure it starts with a letter or underscore
  if (/^[0-9]/.test(sanitized)) {
    sanitized = '_' + sanitized;
  }
  return sanitized || "unnamed_tool";
}

/**
 * Generate requirements.txt
 */
export function generateRequirements() {
  return `mcp>=0.1.0
fastmcp>=0.1.0
uvicorn>=0.30.0
`;
}

/**
 * Generate Dockerfile
 */
export function generateDockerfile() {
  return `FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY mcp_server.py .

EXPOSE 8000

CMD ["python", "mcp_server.py"]
`;
}

/**
 * Generate README
 */
export function generateReadme(toolbox) {
  const name = toolbox.name || toolbox.problem?.statement || "My Toolbox";
  const slug = toSlug(name);
  const tools = toolbox.tools || [];
  const description = toolbox.problem?.statement || toolbox.role?.persona?.split('\n')[0] || '';

  // ── Tools table ──
  const toolList = tools.map((t, i) => {
    const inputs = (t.inputs || []).map(inp => {
      const req = inp.required !== false ? '**required**' : 'optional';
      return `\`${inp.name}\` (${inp.type || 'string'}, ${req})`;
    }).join(', ');
    return `${i + 1}. **${t.name}** — ${t.purpose || t.description || "No description"}${inputs ? `\n   - Inputs: ${inputs}` : ''}`;
  }).join("\n");

  // ── Connector setup sections ──
  let connectorSection = '';
  const connectorIds = new Set();
  if (toolbox.connectors?.length) {
    for (const id of toolbox.connectors) connectorIds.add(id);
  }
  for (const tool of tools) {
    if (tool.source?.type === 'mcp_bridge' && tool.source.connection_id) {
      connectorIds.add(tool.source.connection_id);
    }
  }

  if (connectorIds.size > 0) {
    const allConnectors = getAllPrebuiltConnectors();
    const connectorParts = [];

    for (const connId of connectorIds) {
      const def = allConnectors[connId];
      if (!def) {
        connectorParts.push(`### ${connId}\n\nCustom connector — see \`connectors/${connId}/connector.yaml\` for configuration.\n`);
        continue;
      }

      let part = `### ${def.name}\n\n`;
      part += `${def.description}\n\n`;
      part += `- **Auth Required:** ${def.requiresAuth ? 'Yes' : 'No'}\n`;
      if (def.authInstructions) {
        part += `- **Auth Setup:** ${def.authInstructions}\n`;
      }

      if (def.envRequired?.length) {
        part += `- **Environment Variables:**\n`;
        for (const envName of def.envRequired) {
          const help = def.envHelp?.[envName] || {};
          part += `  - \`${envName}\`: ${help.hint || help.label || envName}`;
          if (help.link) part += ` ([Setup link](${help.link}))`;
          part += '\n';
        }
      }

      part += `- **Config file:** \`connectors/${connId}/connector.yaml\`\n`;
      part += `- **Env template:** \`connectors/${connId}/.env.example\`\n`;
      connectorParts.push(part);
    }

    connectorSection = `## Connector Setup

This skill uses the following connectors (MCP servers):

${connectorParts.join('\n---\n\n')}`;
  }

  // ── File tree ──
  const fileTreeLines = [
    '├── skill.yaml                    # Skill configuration',
    '├── mcp_server.py                 # MCP server implementation',
    '├── requirements.txt              # Python dependencies',
    '├── Dockerfile                    # Container build',
    '├── claude_desktop_config.json    # Claude Desktop config snippet',
    '├── README.md                     # This file',
  ];
  if (connectorIds.size > 0) {
    fileTreeLines.push('└── connectors/');
    const connArr = [...connectorIds];
    connArr.forEach((connId, i) => {
      const prefix = i === connArr.length - 1 ? '    └── ' : '    ├── ';
      const inner  = i === connArr.length - 1 ? '        ' : '    │   ';
      fileTreeLines.push(`${prefix}${connId}/`);
      fileTreeLines.push(`${inner}├── connector.yaml    # Connector config for ADAS`);
      fileTreeLines.push(`${inner}└── .env.example      # Environment variable template`);
    });
  }

  return `# ${name} — MCP Server

Generated by ADAS MCP Toolbox Builder.

${description ? `> ${description}\n` : ''}
## Tools

${toolList}

## Quick Start

### Run Locally

\`\`\`bash
pip install -r requirements.txt
python mcp_server.py
\`\`\`

### Run with Docker

\`\`\`bash
docker build -t ${slug}-mcp .
docker run -p 8000:8000 ${slug}-mcp
\`\`\`

### Add to Claude Desktop

Add to \`~/.claude/config.json\`:

\`\`\`json
{
  "mcpServers": {
    "${slug}": {
      "command": "python",
      "args": ["/path/to/mcp_server.py"]
    }
  }
}
\`\`\`

${connectorSection}
## ADAS Core Deployment

### Option 1: Direct Deploy (Recommended)

Use the Skill Builder UI "Deploy to ADAS" button — this handles skill import
and connector registration automatically.

### Option 2: Manual Import

\`\`\`bash
# 1. Import the skill
curl -X POST http://<adas-core>:4000/api/skills/import \\
  -H "Content-Type: application/json" \\
  -d @adas_payload.json

# 2. Register each connector (if applicable)
${[...connectorIds].map(id => `curl -X POST http://<adas-core>:4000/api/connectors \\
  -H "Content-Type: application/json" \\
  -d @connectors/${id}/connector.yaml`).join('\n\n') || '# No connectors'}
\`\`\`

## Making Connectors UI-Enabled in ADAS Admin

Each \`connector.yaml\` includes a \`ui\` section that defines how the connector
appears in the ADAS Admin settings panel:

\`\`\`yaml
ui:
  icon: mail              # Icon name for the connector card
  color: "#EA4335"        # Brand color
  category: communication # Grouping in the connector catalog
  settings_schema:        # Form fields shown in Admin UI
    - field: EMAIL_USER
      type: string        # string | password | number | boolean
      required: true
      label: Gmail Address
      placeholder: you@gmail.com
      hint: Your full Gmail email address
\`\`\`

The \`settings_schema\` array tells ADAS Admin how to render a configuration
form. Users fill in the fields, and ADAS Core stores the values as encrypted
credentials mapped to the connector's environment variables.

## Testing

### Test with MCP CLI

\`\`\`bash
echo '{"jsonrpc":"2.0","id":"1","method":"tools/list","params":{}}' | python mcp_server.py
\`\`\`

### Test a Specific Tool

\`\`\`bash
echo '{"jsonrpc":"2.0","id":"2","method":"tools/call","params":{"name":"<tool_name>","arguments":{}}}' | python mcp_server.py
\`\`\`

## File Structure

\`\`\`
${fileTreeLines.join('\n')}
\`\`\`

## Customization

The generated code includes mock implementations based on your examples.
Replace the mock logic with actual implementations for production use.
`;
}

/**
 * Generate Claude Desktop config snippet
 */
export function generateClaudeConfig(toolbox) {
  const name = toolbox.problem?.statement || "My Toolbox";
  const slug = toSlug(name);
  
  return JSON.stringify({
    mcpServers: {
      [slug]: {
        command: "python",
        args: ["mcp_server.py"]
      }
    }
  }, null, 2);
}

function toSlug(str) {
  return (str || "toolbox")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "")
    .slice(0, 30);
}

/**
 * Generate skill.yaml - Complete skill configuration
 */
export function generateSkillYaml(skill) {
  const lines = [];

  // Header
  lines.push(`# Skill Configuration`);
  lines.push(`# Generated by ADAS MCP Toolbox Builder`);
  lines.push(`# Version: ${skill.version || 1}`);
  lines.push(``);

  // Basic info
  lines.push(`id: ${yamlString(skill.id || toSlug(skill.name || 'untitled'))}`);
  lines.push(`name: ${yamlString(skill.name || 'Untitled Skill')}`);
  lines.push(`version: ${skill.version || 1}`);
  lines.push(`phase: ${skill.phase || 'DRAFT'}`);
  lines.push(``);

  // MCP Server for skill-specific tools (Multi-Slag Architecture)
  if (skill.mcp_server) {
    lines.push(`# MCP Server for skill-specific tools`);
    lines.push(`mcp_server: ${yamlString(skill.mcp_server)}`);
    lines.push(``);
  }

  // Connectors - extract unique connector IDs from tools with mcp_bridge source
  const connectorIds = new Set();
  for (const tool of (skill.tools || [])) {
    if (tool.source?.type === 'mcp_bridge' && tool.source.connection_id) {
      connectorIds.add(tool.source.connection_id);
    }
  }
  if (connectorIds.size > 0) {
    lines.push(`# Connectors - MCP servers managed by ADAS MCPGateway`);
    lines.push(`connectors:`);
    for (const connectorId of connectorIds) {
      lines.push(`  - ${yamlString(connectorId)}`);
    }
    lines.push(``);
  }

  // UI Plugins - Tier-0 Semantic UI Plugin Control
  if (Array.isArray(skill.ui_plugins) && skill.ui_plugins.length > 0) {
    lines.push(`# UI Plugins - agent-controllable UI plugins (Tier-0 Semantic UI Plugin Control)`);
    lines.push(`ui_plugins:`);
    for (const plugin of skill.ui_plugins) {
      lines.push(`  - id: ${yamlString(plugin.id)}`);
      if (plugin.short_id) {
        lines.push(`    short_id: ${yamlString(plugin.short_id)}`);
      }
    }
    lines.push(``);
  }

  // Problem
  lines.push(`# Problem Definition`);
  lines.push(`problem:`);
  lines.push(`  statement: ${yamlString(skill.problem?.statement || '')}`);
  if (skill.problem?.context) {
    lines.push(`  context: ${yamlString(skill.problem.context)}`);
  }
  if (skill.problem?.goals?.length > 0) {
    lines.push(`  goals:`);
    for (const goal of skill.problem.goals) {
      lines.push(`    - ${yamlString(goal)}`);
    }
  }
  lines.push(``);

  // Role
  if (skill.role?.name || skill.role?.persona) {
    lines.push(`# Agent Role`);
    lines.push(`role:`);
    if (skill.role.name) lines.push(`  name: ${yamlString(skill.role.name)}`);
    if (skill.role.persona) lines.push(`  persona: ${yamlString(skill.role.persona)}`);
    lines.push(``);
  }

  // Top-level persona for Core ADAS Reply Polisher
  if (skill.role?.persona) {
    lines.push(`# Persona (top-level for Core ADAS)`);
    lines.push(`persona: ${yamlString(skill.role.persona)}`);
    lines.push(``);
  }

  // Scenarios
  if (skill.scenarios?.length > 0) {
    lines.push(`# Usage Scenarios`);
    lines.push(`scenarios:`);
    for (const scenario of skill.scenarios) {
      lines.push(`  - id: ${scenario.id || ''}`);
      lines.push(`    title: ${yamlString(scenario.title || '')}`);
      if (scenario.description) {
        lines.push(`    description: ${yamlString(scenario.description)}`);
      }
      if (scenario.steps?.length > 0) {
        lines.push(`    steps:`);
        for (const step of scenario.steps) {
          lines.push(`      - ${yamlString(step)}`);
        }
      }
      if (scenario.expected_outcome) {
        lines.push(`    expected_outcome: ${yamlString(scenario.expected_outcome)}`);
      }
    }
    lines.push(``);
  }

  // Intents
  if (skill.intents?.supported?.length > 0) {
    lines.push(`# Supported Intents`);
    lines.push(`intents:`);
    lines.push(`  supported:`);
    for (const intent of skill.intents.supported) {
      lines.push(`    - id: ${intent.id || ''}`);
      lines.push(`      description: ${yamlString(intent.description || '')}`);
      if (intent.examples?.length > 0) {
        lines.push(`      examples:`);
        for (const example of intent.examples) {
          lines.push(`        - ${yamlString(example)}`);
        }
      }
      if (intent.entities?.length > 0) {
        lines.push(`      entities:`);
        for (const entity of intent.entities) {
          lines.push(`        - name: ${entity.name}`);
          lines.push(`          type: ${entity.type || 'string'}`);
          lines.push(`          required: ${entity.required !== false}`);
        }
      }
    }
    // Out of skill handling
    if (skill.intents.out_of_skill) {
      lines.push(`  out_of_skill:`);
      lines.push(`    action: ${skill.intents.out_of_skill.action || 'redirect'}`);
      if (skill.intents.out_of_skill.message) {
        lines.push(`    message: ${yamlString(skill.intents.out_of_skill.message)}`);
      }
    }
    lines.push(``);
  }

  // Tools (including compiled meta tools)
  // Meta tools are "compiled" into regular tools at export time
  // This way ADAS Core sees them as normal tools - no special handling needed
  const approvedMetaTools = (skill.meta_tools || []).filter(mt => mt.status === 'approved');
  const allTools = [...(skill.tools || [])];

  // Convert meta tools to regular tools
  for (const metaTool of approvedMetaTools) {
    // Collect inputs from all composed tools (deduplicated)
    const composedToolNames = metaTool.composes || [];
    const composedTools = composedToolNames
      .map(name => skill.tools?.find(t => t.name === name))
      .filter(Boolean);

    // Gather unique inputs from all composed tools
    const inputMap = new Map();
    for (const composedTool of composedTools) {
      for (const input of (composedTool.inputs || [])) {
        if (!inputMap.has(input.name)) {
          inputMap.set(input.name, input);
        }
      }
    }

    // Create the meta tool as a regular tool
    const metaAsRegularTool = {
      id: metaTool.id,
      name: metaTool.name,
      description: `${metaTool.description}${metaTool.logic ? ` (Logic: ${metaTool.logic})` : ''}`,
      inputs: Array.from(inputMap.values()),
      output: {
        type: 'object',
        description: `Combined result from: ${composedToolNames.join(', ')}`
      },
      policy: {
        allowed: 'always',
        requires_approval: 'never'
      },
      // Mark as composition for documentation
      _meta: {
        is_composition: true,
        composes: composedToolNames,
        logic: metaTool.logic
      }
    };

    allTools.push(metaAsRegularTool);
  }

  if (allTools.length > 0) {
    lines.push(`# Available Tools`);
    if (approvedMetaTools.length > 0) {
      lines.push(`# Note: Includes ${approvedMetaTools.length} meta tool(s) compiled as regular tools`);
    }
    lines.push(`tools:`);
    for (const tool of allTools) {
      lines.push(`  - id: ${tool.id || ''}`);
      lines.push(`    name: ${yamlString(tool.name || '')}`);
      lines.push(`    description: ${yamlString(tool.description || '')}`);

      // Inputs
      if (tool.inputs?.length > 0) {
        lines.push(`    inputs:`);
        for (const input of tool.inputs) {
          lines.push(`      - name: ${input.name}`);
          lines.push(`        type: ${input.type || 'string'}`);
          lines.push(`        required: ${input.required !== false}`);
          if (input.description) {
            lines.push(`        description: ${yamlString(input.description)}`);
          }
        }
      }

      // Output
      if (tool.output) {
        lines.push(`    output:`);
        lines.push(`      type: ${tool.output.type || 'object'}`);
        if (tool.output.description) {
          lines.push(`      description: ${yamlString(tool.output.description)}`);
        }
        if (tool.output.fields?.length > 0) {
          lines.push(`      fields:`);
          for (const field of tool.output.fields) {
            lines.push(`        - name: ${field.name}`);
            lines.push(`          type: ${field.type || 'string'}`);
            if (field.description) {
              lines.push(`          description: ${yamlString(field.description)}`);
            }
          }
        }
      }

      // Policy
      if (tool.policy) {
        lines.push(`    policy:`);
        lines.push(`      allowed: ${tool.policy.allowed || 'always'}`);
        if (tool.policy.requires_approval) {
          lines.push(`      requires_approval: ${tool.policy.requires_approval}`);
        }
        if (tool.policy.condition) {
          lines.push(`      condition: ${yamlString(tool.policy.condition)}`);
        }
      }

      // Security classification
      if (tool.security) {
        lines.push(`    security:`);
        if (tool.security.classification) {
          lines.push(`      classification: ${yamlString(tool.security.classification)}`);
        }
        if (tool.security.data_owner_field) {
          lines.push(`      data_owner_field: ${yamlString(tool.security.data_owner_field)}`);
        }
        if (tool.security.risk) {
          lines.push(`      risk: ${yamlString(tool.security.risk)}`);
        }
      }

      // Composition metadata (for documentation/debugging)
      if (tool._meta?.is_composition) {
        lines.push(`    # Meta tool - composes: ${tool._meta.composes.join(', ')}`);
      }
    }
    lines.push(``);
  }

  // Policy
  lines.push(`# Policy & Guardrails`);
  lines.push(`policy:`);

  // Guardrails
  lines.push(`  guardrails:`);
  const neverRules = skill.policy?.guardrails?.never || [];
  const alwaysRules = skill.policy?.guardrails?.always || [];

  lines.push(`    never:`);
  if (neverRules.length > 0) {
    for (const rule of neverRules) {
      lines.push(`      - ${yamlString(rule)}`);
    }
  } else {
    lines.push(`      []`);
  }

  lines.push(`    always:`);
  if (alwaysRules.length > 0) {
    for (const rule of alwaysRules) {
      lines.push(`      - ${yamlString(rule)}`);
    }
  } else {
    lines.push(`      []`);
  }

  // Escalation
  if (skill.policy?.escalation) {
    lines.push(`  escalation:`);
    lines.push(`    enabled: ${skill.policy.escalation.enabled || false}`);
    if (skill.policy.escalation.conditions?.length > 0) {
      lines.push(`    conditions:`);
      for (const cond of skill.policy.escalation.conditions) {
        lines.push(`      - ${yamlString(cond)}`);
      }
    }
  }

  // Workflows
  if (skill.policy?.workflows?.length > 0) {
    lines.push(`  workflows:`);
    for (const wf of skill.policy.workflows) {
      lines.push(`    - name: ${yamlString(wf.name || '')}`);
      if (wf.trigger) lines.push(`      trigger: ${yamlString(wf.trigger)}`);
      if (wf.steps?.length > 0) {
        lines.push(`      steps:`);
        for (const step of wf.steps) {
          lines.push(`        - ${yamlString(step)}`);
        }
      }
      lines.push(`      required: ${wf.required || false}`);
    }
  }

  // Approvals (for Core ADAS checkApprovalRequired)
  if (skill.policy?.approvals?.length > 0) {
    lines.push(`  approvals:`);
    for (const approval of skill.policy.approvals) {
      lines.push(`    - tool_id: ${approval.tool_id || ''}`);
      // Convert conditions array to "when" string if present
      if (approval.conditions?.length > 0) {
        const whenParts = approval.conditions.map(c =>
          `${c.field || ''} ${c.operator || '>'} ${c.value || ''}`
        );
        lines.push(`      when: ${yamlString(whenParts.join(' AND '))}`);
      } else if (approval.when) {
        lines.push(`      when: ${yamlString(approval.when)}`);
      }
      if (approval.approver) {
        lines.push(`      approver: ${approval.approver}`);
      }
    }
  }
  lines.push(``);

  // Identity & Access Control - Grant Mappings
  if (skill.grant_mappings?.length > 0) {
    lines.push(`# Identity & Access Control`);
    lines.push(`grant_mappings:`);
    for (const mapping of skill.grant_mappings) {
      lines.push(`  - tool: ${yamlString(mapping.tool || '')}`);
      if (mapping.on_success !== undefined) {
        lines.push(`    on_success: ${mapping.on_success}`);
      }
      if (mapping.grants?.length > 0) {
        lines.push(`    grants:`);
        for (const grant of mapping.grants) {
          lines.push(`      - key: ${yamlString(grant.key || '')}`);
          if (grant.value_from) {
            lines.push(`        value_from: ${yamlString(grant.value_from)}`);
          }
          if (grant.ttl_seconds !== undefined) {
            lines.push(`        ttl_seconds: ${grant.ttl_seconds}`);
          }
        }
      }
    }
    lines.push(``);
  }

  // Access Policy
  if (skill.access_policy?.rules?.length > 0) {
    lines.push(`access_policy:`);
    lines.push(`  rules:`);
    for (const rule of skill.access_policy.rules) {
      if (rule.tools?.length > 0) {
        lines.push(`    - tools: [${rule.tools.map(t => yamlString(t)).join(', ')}]`);
      } else {
        lines.push(`    - tools: []`);
      }
      if (rule.when) {
        lines.push(`      when:`);
        for (const [key, value] of Object.entries(rule.when)) {
          lines.push(`        ${key}: ${yamlString(value)}`);
        }
      }
      if (rule.require) {
        lines.push(`      require:`);
        for (const [key, value] of Object.entries(rule.require)) {
          lines.push(`        ${key}: ${yamlString(value)}`);
        }
      }
      if (rule.effect) {
        lines.push(`      effect: ${yamlString(rule.effect)}`);
      }
      if (rule.constrain) {
        lines.push(`      constrain:`);
        if (rule.constrain.inject_args) {
          lines.push(`        inject_args:`);
          for (const [key, value] of Object.entries(rule.constrain.inject_args)) {
            lines.push(`          ${key}: ${yamlString(value)}`);
          }
        }
        if (rule.constrain.response_filter) {
          lines.push(`        response_filter: ${yamlString(rule.constrain.response_filter)}`);
        }
      }
    }
    lines.push(``);
  }

  // Response Filters
  if (skill.response_filters?.length > 0) {
    lines.push(`response_filters:`);
    for (const filter of skill.response_filters) {
      lines.push(`  - id: ${yamlString(filter.id || '')}`);
      if (filter.description) {
        lines.push(`    description: ${yamlString(filter.description)}`);
      }
      if (filter.unless_grant) {
        lines.push(`    unless_grant: ${yamlString(filter.unless_grant)}`);
      }
      if (filter.strip_fields?.length > 0) {
        lines.push(`    strip_fields:`);
        for (const field of filter.strip_fields) {
          lines.push(`      - ${yamlString(field)}`);
        }
      }
      if (filter.mask_fields?.length > 0) {
        lines.push(`    mask_fields:`);
        for (const mf of filter.mask_fields) {
          lines.push(`      - field: ${yamlString(mf.field || '')}`);
          if (mf.mask) {
            lines.push(`        mask: ${yamlString(mf.mask)}`);
          }
        }
      }
    }
    lines.push(``);
  }

  // Context Propagation
  if (skill.context_propagation?.on_handoff) {
    lines.push(`context_propagation:`);
    lines.push(`  on_handoff:`);
    const handoff = skill.context_propagation.on_handoff;
    if (handoff.propagate_grants?.length > 0) {
      lines.push(`    propagate_grants:`);
      for (const grant of handoff.propagate_grants) {
        lines.push(`      - ${yamlString(grant)}`);
      }
    }
    if (handoff.drop_grants?.length > 0) {
      lines.push(`    drop_grants:`);
      for (const grant of handoff.drop_grants) {
        lines.push(`      - ${yamlString(grant)}`);
      }
    }
    lines.push(``);
  }

  // Engine settings
  lines.push(`# Engine Configuration`);
  lines.push(`engine:`);
  lines.push(`  model: ${skill.engine?.model || 'default'}`);
  lines.push(`  temperature: ${skill.engine?.temperature ?? 0.7}`);
  lines.push(`  max_tokens: ${skill.engine?.max_tokens || 4096}`);
  // RV2 Engine settings - max_iterations is the main iteration limit
  lines.push(`  max_iterations: ${skill.engine?.rv2?.max_iterations ?? 16}`);
  lines.push(`  timeout: ${skill.engine?.rv2?.timeout ?? 60000}`);
  lines.push(`  on_max_iterations: ${skill.engine?.rv2?.on_max_iterations ?? 'ask_user'}`);
  if (skill.engine?.response_format) {
    lines.push(`  response_format: ${skill.engine.response_format}`);
  }
  // Finalization Gate config (for Core ADAS)
  lines.push(`  finalization_gate:`);
  lines.push(`    enabled: ${skill.engine?.finalization_gate?.enabled ?? true}`);
  lines.push(`    max_retries: ${skill.engine?.finalization_gate?.max_retries ?? 2}`);

  // Internal Error Handling (RV2 Sprint)
  lines.push(`  internal_error:`);
  lines.push(`    enabled: ${skill.engine?.internal_error?.enabled ?? true}`);
  lines.push(`    tool_not_found:`);
  lines.push(`      enter_resolution_after: ${skill.engine?.internal_error?.tool_not_found?.enter_resolution_after ?? 1}`);
  lines.push(`      retryable: ${skill.engine?.internal_error?.tool_not_found?.retryable ?? false}`);
  lines.push(`    resolution:`);
  lines.push(`      max_iterations: ${skill.engine?.internal_error?.resolution?.max_iterations ?? 1}`);
  const allowedCaps = skill.engine?.internal_error?.resolution?.allowed_capabilities || ['read', 'search', 'document_output'];
  lines.push(`      allowed_capabilities: [${allowedCaps.map(c => `"${c}"`).join(', ')}]`);
  lines.push(`    loop_detection:`);
  lines.push(`      enabled: ${skill.engine?.internal_error?.loop_detection?.enabled ?? true}`);
  lines.push(`      identical_call_threshold: ${skill.engine?.internal_error?.loop_detection?.identical_call_threshold ?? 2}`);

  // Output Contract (for Core ADAS Finalization Gate)
  if (skill.output_contract?.required_fields?.length > 0) {
    lines.push(``);
    lines.push(`# Output Contract`);
    lines.push(`output_contract:`);
    lines.push(`  required_fields:`);
    for (const field of skill.output_contract.required_fields) {
      lines.push(`    - ${yamlString(field)}`);
    }
  }

  return lines.join('\n');
}

/**
 * Helper to escape YAML strings
 */
function yamlString(str) {
  if (str === null || str === undefined) return '""';
  const s = String(str);
  // If contains special chars or newlines, quote it
  if (s.includes(':') || s.includes('#') || s.includes('\n') || s.includes('"') || s.includes("'") || s.startsWith(' ') || s.endsWith(' ')) {
    // Use double quotes and escape internal quotes
    return `"${s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n')}"`;
  }
  return s || '""';
}

/**
 * Generate all export files (original MCP format)
 */
export function generateExportFiles(toolbox) {
  const connectorFiles = generateAllConnectorFiles(toolbox);
  return [
    { name: "skill.yaml", content: generateSkillYaml(toolbox) },
    { name: "mcp_server.py", content: generateMCPServer(toolbox) },
    { name: "requirements.txt", content: generateRequirements() },
    { name: "Dockerfile", content: generateDockerfile() },
    { name: "README.md", content: generateReadme(toolbox) },
    { name: "claude_desktop_config.json", content: generateClaudeConfig(toolbox) },
    ...connectorFiles
  ];
}


export default {
  generateMCPServer,
  generateRequirements,
  generateDockerfile,
  generateReadme,
  generateClaudeConfig,
  generateSkillYaml,
  generateExportFiles,
};
