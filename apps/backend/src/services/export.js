/**
 * Generate MCP server code from toolbox definition
 */

export function generateMCPServer(toolbox) {
  const tools = toolbox.tools || [];
  const name = toolbox.problem?.statement || "My Toolbox";
  
  // Generate tool functions
  const toolFunctions = tools.map(tool => generateToolFunction(tool)).join("\n\n");
  
  return `"""
MCP Server: ${name}
Generated by ADAS MCP Toolbox Builder
Version: ${toolbox.version || 1}
"""

from mcp.server.fastmcp import FastMCP

mcp = FastMCP("${escapeString(name)}")

${toolFunctions}

if __name__ == "__main__":
    mcp.run()
`;
}

function generateToolFunction(tool) {
  const inputs = tool.inputs || [];
  const output = tool.output || {};
  const mock = tool.mock || {};
  
  // Generate function signature
  const params = inputs.map(inp => {
    const typeHint = pythonType(inp.type);
    if (inp.required === false) {
      return `${inp.name}: ${typeHint} = None`;
    }
    return `${inp.name}: ${typeHint}`;
  }).join(", ");
  
  // Generate docstring
  const docstring = generateDocstring(tool);
  
  // Generate mock implementation
  const mockImpl = generateMockImplementation(tool);
  
  return `@mcp.tool()
def ${tool.name}(${params}) -> dict:
${docstring}
${mockImpl}`;
}

function generateDocstring(tool) {
  const lines = [`    """`, `    ${tool.purpose || "Tool description"}`];
  
  if (tool.inputs?.length > 0) {
    lines.push("");
    lines.push("    Args:");
    for (const inp of tool.inputs) {
      lines.push(`        ${inp.name}: ${inp.description || inp.type}`);
    }
  }
  
  if (tool.output) {
    lines.push("");
    lines.push("    Returns:");
    lines.push(`        ${tool.output.description || "Result object"}`);
  }
  
  lines.push(`    """`);
  return lines.join("\n");
}

function generateMockImplementation(tool) {
  const mock = tool.mock || {};
  const examples = mock.examples || [];
  
  if (examples.length === 0) {
    return `    # TODO: Implement actual logic
    return {"status": "not_implemented"}`;
  }
  
  // Generate mock data lookup
  const lines = [
    "    # Mock implementation for testing",
    "    # TODO: Replace with actual logic",
    "    mock_data = {"
  ];
  
  for (const example of examples) {
    const key = JSON.stringify(example.input);
    const value = JSON.stringify(example.output);
    lines.push(`        ${key}: ${value},`);
  }
  
  lines.push("    }");
  lines.push("");
  lines.push("    # Try to find matching mock data");
  lines.push(`    input_key = ${generateInputKey(tool.inputs)}`);
  lines.push("    if input_key in mock_data:");
  lines.push("        return mock_data[input_key]");
  lines.push("");
  lines.push("    # Default response if no mock match");
  
  // Use first example output as template
  if (examples[0]?.output) {
    const defaultOutput = { ...examples[0].output, _note: "No matching mock data" };
    lines.push(`    return ${JSON.stringify(defaultOutput)}`);
  } else {
    lines.push(`    return {"error": "No matching mock data"}`);
  }
  
  return lines.map(l => "    " + l.slice(4)).join("\n");
}

function generateInputKey(inputs) {
  if (!inputs || inputs.length === 0) {
    return '"{}"';
  }
  
  const parts = inputs.map(inp => `"${inp.name}": ${inp.name}`).join(", ");
  return `str({${parts}})`;
}

function pythonType(type) {
  switch (type?.toLowerCase()) {
    case "string":
    case "text":
      return "str";
    case "number":
    case "integer":
    case "int":
      return "int";
    case "float":
    case "decimal":
      return "float";
    case "boolean":
    case "bool":
      return "bool";
    case "array":
    case "list":
      return "list";
    case "object":
    case "dict":
      return "dict";
    default:
      return "str";
  }
}

function escapeString(str) {
  return (str || "").replace(/"/g, '\\"').replace(/\n/g, "\\n");
}

/**
 * Generate requirements.txt
 */
export function generateRequirements() {
  return `mcp>=0.1.0
fastmcp>=0.1.0
`;
}

/**
 * Generate Dockerfile
 */
export function generateDockerfile() {
  return `FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY mcp_server.py .

EXPOSE 8000

CMD ["python", "mcp_server.py"]
`;
}

/**
 * Generate README
 */
export function generateReadme(toolbox) {
  const name = toolbox.problem?.statement || "My Toolbox";
  const tools = toolbox.tools || [];
  
  const toolList = tools.map((t, i) => 
    `${i + 1}. **${t.name}** - ${t.purpose || "No description"}`
  ).join("\n");
  
  return `# ${name} - MCP Server

Generated by ADAS MCP Toolbox Builder.

## Tools Included

${toolList}

## Setup

### Option 1: Run Locally

\`\`\`bash
pip install -r requirements.txt
python mcp_server.py
\`\`\`

### Option 2: Run with Docker

\`\`\`bash
docker build -t ${toSlug(name)}-mcp .
docker run -p 8000:8000 ${toSlug(name)}-mcp
\`\`\`

### Option 3: Add to Claude Desktop

Add to your Claude Desktop config (\`~/.claude/config.json\`):

\`\`\`json
{
  "mcpServers": {
    "${toSlug(name)}": {
      "command": "python",
      "args": ["/path/to/mcp_server.py"]
    }
  }
}
\`\`\`

## Customization

The generated code includes mock implementations based on your examples.
Replace the mock logic with actual implementations for production use.
`;
}

/**
 * Generate Claude Desktop config snippet
 */
export function generateClaudeConfig(toolbox) {
  const name = toolbox.problem?.statement || "My Toolbox";
  const slug = toSlug(name);
  
  return JSON.stringify({
    mcpServers: {
      [slug]: {
        command: "python",
        args: ["mcp_server.py"]
      }
    }
  }, null, 2);
}

function toSlug(str) {
  return (str || "toolbox")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "")
    .slice(0, 30);
}

/**
 * Generate domain.yaml - Complete domain configuration
 */
export function generateDomainYaml(domain) {
  const lines = [];

  // Header
  lines.push(`# Domain Configuration`);
  lines.push(`# Generated by ADAS MCP Toolbox Builder`);
  lines.push(`# Version: ${domain.version || 1}`);
  lines.push(``);

  // Basic info
  lines.push(`name: ${yamlString(domain.name || 'Untitled Domain')}`);
  lines.push(`version: ${domain.version || 1}`);
  lines.push(`phase: ${domain.phase || 'DRAFT'}`);
  lines.push(``);

  // Problem
  lines.push(`# Problem Definition`);
  lines.push(`problem:`);
  lines.push(`  statement: ${yamlString(domain.problem?.statement || '')}`);
  if (domain.problem?.context) {
    lines.push(`  context: ${yamlString(domain.problem.context)}`);
  }
  if (domain.problem?.goals?.length > 0) {
    lines.push(`  goals:`);
    for (const goal of domain.problem.goals) {
      lines.push(`    - ${yamlString(goal)}`);
    }
  }
  lines.push(``);

  // Role
  if (domain.role?.name || domain.role?.persona) {
    lines.push(`# Agent Role`);
    lines.push(`role:`);
    if (domain.role.name) lines.push(`  name: ${yamlString(domain.role.name)}`);
    if (domain.role.persona) lines.push(`  persona: ${yamlString(domain.role.persona)}`);
    lines.push(``);
  }

  // Top-level persona for Core ADAS Reply Polisher
  if (domain.role?.persona) {
    lines.push(`# Persona (top-level for Core ADAS)`);
    lines.push(`persona: ${yamlString(domain.role.persona)}`);
    lines.push(``);
  }

  // Scenarios
  if (domain.scenarios?.length > 0) {
    lines.push(`# Usage Scenarios`);
    lines.push(`scenarios:`);
    for (const scenario of domain.scenarios) {
      lines.push(`  - id: ${scenario.id || ''}`);
      lines.push(`    title: ${yamlString(scenario.title || '')}`);
      if (scenario.description) {
        lines.push(`    description: ${yamlString(scenario.description)}`);
      }
      if (scenario.steps?.length > 0) {
        lines.push(`    steps:`);
        for (const step of scenario.steps) {
          lines.push(`      - ${yamlString(step)}`);
        }
      }
      if (scenario.expected_outcome) {
        lines.push(`    expected_outcome: ${yamlString(scenario.expected_outcome)}`);
      }
    }
    lines.push(``);
  }

  // Intents
  if (domain.intents?.supported?.length > 0) {
    lines.push(`# Supported Intents`);
    lines.push(`intents:`);
    lines.push(`  supported:`);
    for (const intent of domain.intents.supported) {
      lines.push(`    - id: ${intent.id || ''}`);
      lines.push(`      description: ${yamlString(intent.description || '')}`);
      if (intent.examples?.length > 0) {
        lines.push(`      examples:`);
        for (const example of intent.examples) {
          lines.push(`        - ${yamlString(example)}`);
        }
      }
      if (intent.entities?.length > 0) {
        lines.push(`      entities:`);
        for (const entity of intent.entities) {
          lines.push(`        - name: ${entity.name}`);
          lines.push(`          type: ${entity.type || 'string'}`);
          lines.push(`          required: ${entity.required !== false}`);
        }
      }
    }
    // Out of domain handling
    if (domain.intents.out_of_domain) {
      lines.push(`  out_of_domain:`);
      lines.push(`    action: ${domain.intents.out_of_domain.action || 'redirect'}`);
      if (domain.intents.out_of_domain.message) {
        lines.push(`    message: ${yamlString(domain.intents.out_of_domain.message)}`);
      }
    }
    lines.push(``);
  }

  // Tools
  if (domain.tools?.length > 0) {
    lines.push(`# Available Tools`);
    lines.push(`tools:`);
    for (const tool of domain.tools) {
      lines.push(`  - id: ${tool.id || ''}`);
      lines.push(`    name: ${yamlString(tool.name || '')}`);
      lines.push(`    description: ${yamlString(tool.description || '')}`);

      // Inputs
      if (tool.inputs?.length > 0) {
        lines.push(`    inputs:`);
        for (const input of tool.inputs) {
          lines.push(`      - name: ${input.name}`);
          lines.push(`        type: ${input.type || 'string'}`);
          lines.push(`        required: ${input.required !== false}`);
          if (input.description) {
            lines.push(`        description: ${yamlString(input.description)}`);
          }
        }
      }

      // Output
      if (tool.output) {
        lines.push(`    output:`);
        lines.push(`      type: ${tool.output.type || 'object'}`);
        if (tool.output.description) {
          lines.push(`      description: ${yamlString(tool.output.description)}`);
        }
        if (tool.output.fields?.length > 0) {
          lines.push(`      fields:`);
          for (const field of tool.output.fields) {
            lines.push(`        - name: ${field.name}`);
            lines.push(`          type: ${field.type || 'string'}`);
            if (field.description) {
              lines.push(`          description: ${yamlString(field.description)}`);
            }
          }
        }
      }

      // Policy
      if (tool.policy) {
        lines.push(`    policy:`);
        lines.push(`      allowed: ${tool.policy.allowed || 'always'}`);
        if (tool.policy.requires_approval) {
          lines.push(`      requires_approval: ${tool.policy.requires_approval}`);
        }
        if (tool.policy.condition) {
          lines.push(`      condition: ${yamlString(tool.policy.condition)}`);
        }
      }
    }
    lines.push(``);
  }

  // Policy
  lines.push(`# Policy & Guardrails`);
  lines.push(`policy:`);

  // Guardrails
  lines.push(`  guardrails:`);
  const neverRules = domain.policy?.guardrails?.never || [];
  const alwaysRules = domain.policy?.guardrails?.always || [];

  lines.push(`    never:`);
  if (neverRules.length > 0) {
    for (const rule of neverRules) {
      lines.push(`      - ${yamlString(rule)}`);
    }
  } else {
    lines.push(`      []`);
  }

  lines.push(`    always:`);
  if (alwaysRules.length > 0) {
    for (const rule of alwaysRules) {
      lines.push(`      - ${yamlString(rule)}`);
    }
  } else {
    lines.push(`      []`);
  }

  // Escalation
  if (domain.policy?.escalation) {
    lines.push(`  escalation:`);
    lines.push(`    enabled: ${domain.policy.escalation.enabled || false}`);
    if (domain.policy.escalation.conditions?.length > 0) {
      lines.push(`    conditions:`);
      for (const cond of domain.policy.escalation.conditions) {
        lines.push(`      - ${yamlString(cond)}`);
      }
    }
  }

  // Workflows
  if (domain.policy?.workflows?.length > 0) {
    lines.push(`  workflows:`);
    for (const wf of domain.policy.workflows) {
      lines.push(`    - name: ${yamlString(wf.name || '')}`);
      if (wf.trigger) lines.push(`      trigger: ${yamlString(wf.trigger)}`);
      if (wf.steps?.length > 0) {
        lines.push(`      steps:`);
        for (const step of wf.steps) {
          lines.push(`        - ${yamlString(step)}`);
        }
      }
      lines.push(`      required: ${wf.required || false}`);
    }
  }

  // Approvals (for Core ADAS checkApprovalRequired)
  if (domain.policy?.approvals?.length > 0) {
    lines.push(`  approvals:`);
    for (const approval of domain.policy.approvals) {
      lines.push(`    - tool_id: ${approval.tool_id || ''}`);
      // Convert conditions array to "when" string if present
      if (approval.conditions?.length > 0) {
        const whenParts = approval.conditions.map(c =>
          `${c.field || ''} ${c.operator || '>'} ${c.value || ''}`
        );
        lines.push(`      when: ${yamlString(whenParts.join(' AND '))}`);
      } else if (approval.when) {
        lines.push(`      when: ${yamlString(approval.when)}`);
      }
      if (approval.approver) {
        lines.push(`      approver: ${approval.approver}`);
      }
    }
  }
  lines.push(``);

  // Engine settings
  lines.push(`# Engine Configuration`);
  lines.push(`engine:`);
  lines.push(`  model: ${domain.engine?.model || 'default'}`);
  lines.push(`  temperature: ${domain.engine?.temperature ?? 0.7}`);
  lines.push(`  max_tokens: ${domain.engine?.max_tokens || 4096}`);
  if (domain.engine?.response_format) {
    lines.push(`  response_format: ${domain.engine.response_format}`);
  }
  // Finalization Gate config (for Core ADAS)
  lines.push(`  finalization_gate:`);
  lines.push(`    enabled: ${domain.engine?.finalization_gate?.enabled ?? true}`);
  lines.push(`    max_retries: ${domain.engine?.finalization_gate?.max_retries ?? 2}`);

  // Output Contract (for Core ADAS Finalization Gate)
  if (domain.output_contract?.required_fields?.length > 0) {
    lines.push(``);
    lines.push(`# Output Contract`);
    lines.push(`output_contract:`);
    lines.push(`  required_fields:`);
    for (const field of domain.output_contract.required_fields) {
      lines.push(`    - ${yamlString(field)}`);
    }
  }

  return lines.join('\n');
}

/**
 * Helper to escape YAML strings
 */
function yamlString(str) {
  if (str === null || str === undefined) return '""';
  const s = String(str);
  // If contains special chars or newlines, quote it
  if (s.includes(':') || s.includes('#') || s.includes('\n') || s.includes('"') || s.includes("'") || s.startsWith(' ') || s.endsWith(' ')) {
    // Use double quotes and escape internal quotes
    return `"${s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n')}"`;
  }
  return s || '""';
}

/**
 * Generate all export files
 */
export function generateExportFiles(toolbox) {
  return [
    { name: "domain.yaml", content: generateDomainYaml(toolbox) },
    { name: "mcp_server.py", content: generateMCPServer(toolbox) },
    { name: "requirements.txt", content: generateRequirements() },
    { name: "Dockerfile", content: generateDockerfile() },
    { name: "README.md", content: generateReadme(toolbox) },
    { name: "claude_desktop_config.json", content: generateClaudeConfig(toolbox) }
  ];
}

export default {
  generateMCPServer,
  generateRequirements,
  generateDockerfile,
  generateReadme,
  generateClaudeConfig,
  generateDomainYaml,
  generateExportFiles
};
