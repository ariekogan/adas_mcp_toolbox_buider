/**
 * Generate MCP server code from toolbox definition
 */

export function generateMCPServer(toolbox) {
  const tools = toolbox.tools || [];
  const name = toolbox.problem?.statement || "My Toolbox";
  
  // Generate tool functions
  const toolFunctions = tools.map(tool => generateToolFunction(tool)).join("\n\n");
  
  return `"""
MCP Server: ${name}
Generated by ADAS MCP Toolbox Builder
Version: ${toolbox.version || 1}
"""

from mcp.server.fastmcp import FastMCP

mcp = FastMCP("${escapeString(name)}")

${toolFunctions}

if __name__ == "__main__":
    mcp.run()
`;
}

function generateToolFunction(tool) {
  const inputs = tool.inputs || [];
  const output = tool.output || {};
  const mock = tool.mock || {};
  
  // Generate function signature
  const params = inputs.map(inp => {
    const typeHint = pythonType(inp.type);
    if (inp.required === false) {
      return `${inp.name}: ${typeHint} = None`;
    }
    return `${inp.name}: ${typeHint}`;
  }).join(", ");
  
  // Generate docstring
  const docstring = generateDocstring(tool);
  
  // Generate mock implementation
  const mockImpl = generateMockImplementation(tool);
  
  return `@mcp.tool()
def ${tool.name}(${params}) -> dict:
${docstring}
${mockImpl}`;
}

function generateDocstring(tool) {
  const lines = [`    """`, `    ${tool.purpose || "Tool description"}`];
  
  if (tool.inputs?.length > 0) {
    lines.push("");
    lines.push("    Args:");
    for (const inp of tool.inputs) {
      lines.push(`        ${inp.name}: ${inp.description || inp.type}`);
    }
  }
  
  if (tool.output) {
    lines.push("");
    lines.push("    Returns:");
    lines.push(`        ${tool.output.description || "Result object"}`);
  }
  
  lines.push(`    """`);
  return lines.join("\n");
}

function generateMockImplementation(tool) {
  const mock = tool.mock || {};
  const examples = mock.examples || [];
  
  if (examples.length === 0) {
    return `    # TODO: Implement actual logic
    return {"status": "not_implemented"}`;
  }
  
  // Generate mock data lookup
  const lines = [
    "    # Mock implementation for testing",
    "    # TODO: Replace with actual logic",
    "    mock_data = {"
  ];
  
  for (const example of examples) {
    const key = JSON.stringify(example.input);
    const value = JSON.stringify(example.output);
    lines.push(`        ${key}: ${value},`);
  }
  
  lines.push("    }");
  lines.push("");
  lines.push("    # Try to find matching mock data");
  lines.push(`    input_key = ${generateInputKey(tool.inputs)}`);
  lines.push("    if input_key in mock_data:");
  lines.push("        return mock_data[input_key]");
  lines.push("");
  lines.push("    # Default response if no mock match");
  
  // Use first example output as template
  if (examples[0]?.output) {
    const defaultOutput = { ...examples[0].output, _note: "No matching mock data" };
    lines.push(`    return ${JSON.stringify(defaultOutput)}`);
  } else {
    lines.push(`    return {"error": "No matching mock data"}`);
  }
  
  return lines.map(l => "    " + l.slice(4)).join("\n");
}

function generateInputKey(inputs) {
  if (!inputs || inputs.length === 0) {
    return '"{}"';
  }
  
  const parts = inputs.map(inp => `"${inp.name}": ${inp.name}`).join(", ");
  return `str({${parts}})`;
}

function pythonType(type) {
  switch (type?.toLowerCase()) {
    case "string":
    case "text":
      return "str";
    case "number":
    case "integer":
    case "int":
      return "int";
    case "float":
    case "decimal":
      return "float";
    case "boolean":
    case "bool":
      return "bool";
    case "array":
    case "list":
      return "list";
    case "object":
    case "dict":
      return "dict";
    default:
      return "str";
  }
}

function escapeString(str) {
  return (str || "").replace(/"/g, '\\"').replace(/\n/g, "\\n");
}

/**
 * Generate requirements.txt
 */
export function generateRequirements() {
  return `mcp>=0.1.0
fastmcp>=0.1.0
`;
}

/**
 * Generate Dockerfile
 */
export function generateDockerfile() {
  return `FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY mcp_server.py .

EXPOSE 8000

CMD ["python", "mcp_server.py"]
`;
}

/**
 * Generate README
 */
export function generateReadme(toolbox) {
  const name = toolbox.problem?.statement || "My Toolbox";
  const tools = toolbox.tools || [];
  
  const toolList = tools.map((t, i) => 
    `${i + 1}. **${t.name}** - ${t.purpose || "No description"}`
  ).join("\n");
  
  return `# ${name} - MCP Server

Generated by ADAS MCP Toolbox Builder.

## Tools Included

${toolList}

## Setup

### Option 1: Run Locally

\`\`\`bash
pip install -r requirements.txt
python mcp_server.py
\`\`\`

### Option 2: Run with Docker

\`\`\`bash
docker build -t ${toSlug(name)}-mcp .
docker run -p 8000:8000 ${toSlug(name)}-mcp
\`\`\`

### Option 3: Add to Claude Desktop

Add to your Claude Desktop config (\`~/.claude/config.json\`):

\`\`\`json
{
  "mcpServers": {
    "${toSlug(name)}": {
      "command": "python",
      "args": ["/path/to/mcp_server.py"]
    }
  }
}
\`\`\`

## Customization

The generated code includes mock implementations based on your examples.
Replace the mock logic with actual implementations for production use.
`;
}

/**
 * Generate Claude Desktop config snippet
 */
export function generateClaudeConfig(toolbox) {
  const name = toolbox.problem?.statement || "My Toolbox";
  const slug = toSlug(name);
  
  return JSON.stringify({
    mcpServers: {
      [slug]: {
        command: "python",
        args: ["mcp_server.py"]
      }
    }
  }, null, 2);
}

function toSlug(str) {
  return (str || "toolbox")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "")
    .slice(0, 30);
}

/**
 * Generate all export files
 */
export function generateExportFiles(toolbox) {
  return [
    { name: "mcp_server.py", content: generateMCPServer(toolbox) },
    { name: "requirements.txt", content: generateRequirements() },
    { name: "Dockerfile", content: generateDockerfile() },
    { name: "README.md", content: generateReadme(toolbox) },
    { name: "claude_desktop_config.json", content: generateClaudeConfig(toolbox) }
  ];
}

export default { 
  generateMCPServer, 
  generateRequirements, 
  generateDockerfile, 
  generateReadme, 
  generateClaudeConfig,
  generateExportFiles 
};
